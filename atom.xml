<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-24T13:40:53.210Z</updated>
  <id>http://example.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js的异步串行与异步并行</title>
    <link href="http://example.com/2023/04/24/js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%8Cjs%E7%9A%84%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C/"/>
    <id>http://example.com/2023/04/24/js%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%EF%BC%8Cjs%E7%9A%84%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C/</id>
    <published>2023-04-24T13:40:33.652Z</published>
    <updated>2023-04-24T13:40:53.210Z</updated>
    
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>hooks进阶</title>
    <link href="http://example.com/2023/04/24/03-hooks%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2023/04/24/03-hooks%E8%BF%9B%E9%98%B6/</id>
    <published>2023-04-24T11:16:07.104Z</published>
    <updated>2023-04-24T11:56:26.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hooks其他API"><a href="#Hooks其他API" class="headerlink" title="Hooks其他API"></a>Hooks其他API</h1><h2 id="useRef-hook"><a href="#useRef-hook" class="headerlink" title="useRef hook"></a>useRef hook</h2><h2 id="useContext-hook"><a href="#useContext-hook" class="headerlink" title="useContext hook"></a>useContext hook</h2><h1 id="Hooks进阶"><a href="#Hooks进阶" class="headerlink" title="Hooks进阶"></a>Hooks进阶</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>根据前面的学习我们知道，Hooks（内置或自定义）只能在函数组件中使用。因此，Hooks 与函数组件是密不可分的。</p><p>所以，要想深入理解 Hooks，就必须先理解函数组件的特性，因为这些特性会影响到了 Hooks 的使用。</p><p>本节，我们先来理解函数组件的特性。然后，根据这些特性对实际开发产生的影响，我们再来学习 <strong>useCallback / useMemo / useRef</strong> 等内置 Hooks。</p><p>最后，我们来模拟实现 useState / useEffect 这两个 Hooks，来深入理解 Hooks 的实现原理。</p><h2 id="函数组件的特性"><a href="#函数组件的特性" class="headerlink" title="函数组件的特性"></a>函数组件的特性</h2><p>React 中的函数组件是通过函数来实现的，函数组件的公式：<code>f(state) =&gt; UI</code>，即：数据到视图的映射。</p><p>函数组件本身很简单，但因为是通过函数实现的，所以，在使用函数组件时，就会体现出函数所具有的特性来。</p><p>函数组件的特性说明：</p><ul><li>对于函数组件来说，每次状态更新后，组件都会重新渲染。</li><li>并且，<strong>每次组件更新都像是在给组件拍照。每张照片就代表组件在某个特定时刻的状态。</strong></li><li>或者说：<code>组件的每次特定渲染，都有自己的 props/state/事件处理程序</code> 等。</li><li>这些照片记录的状态，从代码层面来说，是通过 JS 中函数的闭包机制来实现的。</li></ul><p>这就是 React 中函数组件的特性，更加的函数式（利用函数的特性）</p><pre class="highlight"><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 hooks 的函数组件：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params">&#123; count &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// console.log(count)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">showCount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;展示 count 值：&#x27;</span>, count)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;showCount&#125;</span>&gt;</span>点击按钮3秒后显示count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>计数器：&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 子组件 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Counter</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br></pre><h2 id="函数组件特性带来的问题"><a href="#函数组件特性带来的问题" class="headerlink" title="函数组件特性带来的问题"></a>函数组件特性带来的问题</h2><p>函数组件的特性：<strong>组件的每次特定渲染，都有自己的 props/state/事件处理程序 等。</strong></p><p>该特性，导致了几个问题：</p><ul><li>组件每次重新渲染时，<em>组件内部的事件处理程序等函数都会重新创建，导致子组件每次都会接收到不同的 props，从而重复进行不必要的渲染（性能问题）</em>。</li><li>组件内的事件处理程序等函数中，只能获取到那一次特定渲染时的数据，这是合理的（闭包的原因）。</li></ul><p>说明：函数组件配合 Hooks 使用时，会不会因为闭包以及每次都创建新的函数等，让组件变慢？答案：<a href="https://react.docschina.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render">不会！</a></p><p>注意：在没有发现性能问题前，避免过早的性能优化。如果要优化，一定要考虑优化成本是否大于优化后的价值。</p><p>对于第一个问题，我们使用 <code>React.memo</code> 配合 <code>useCallback/useMemo</code> 这两个 Hooks 来解决。</p><p>对于第二个问题，我们使用 <code>useRef Hook</code> 来解决。</p><h2 id="React-memo高阶组件"><a href="#React-memo高阶组件" class="headerlink" title="React.memo高阶组件"></a>React.memo高阶组件</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>React.memo 高阶组件的使用场景说明：</p><p>React 组件更新机制：只要父组件状态更新，子组件就会无条件的一起更新。</p><ul><li>子组件 props 变化时更新过程：组件代码执行 -&gt; JSX Diff（配合虚拟 DOM）-&gt; 渲染（变化后的内容）【 DOM 操作】。</li><li>子组件 props 无变化更新过程：组件代码执行 -&gt; JSX Diff（配合虚拟 DOM）【无 DOM 操作】。</li></ul><p>注意：此处更新指的是组件代码执行、JSX 进行 Diff 操作（纯 JS 的操作，速度非常快，不会对性能产生太多影响）。</p><ul><li>如果组件 props 改变了，那么，该组件就必须要更新，才能接收到最新的 props。</li><li>但是，如果组件 props 没有改变时，组件也要进行一次更新。实际上，这一次更新是没有必要的。</li></ul><p>如果要避免组件 props 没有变化而进行的不必要更新（Diff），这种情况下，就要使用 React.memo 高阶组件。</p><p>注：<code>对于 class 组件来说，可以使用 PureComponent 或 shouldComponentUpdate 钩子函数来实现</code>。</p><pre class="highlight"><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child2</span> = (<span class="params">&#123; count &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Child2 子组件代码执行了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundColor:</span> &#x27;#<span class="attr">abc</span>&#x27; &#125;&#125;&gt;</span>子组件2：&#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Child1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Child1 子组件代码执行了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundColor:</span> &#x27;#<span class="attr">def</span>&#x27; &#125;&#125;&gt;</span>子组件1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundColor:</span> &#x27;<span class="attr">pink</span>&#x27;, <span class="attr">padding:</span> <span class="attr">10</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>计数器：&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;/* 子组件 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child2</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br></pre><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>使用场景：当你想要避免函数组件 props 没有变化而产生的不必要更新时，就要用到 React.memo 了。</p><p>作用：<strong>记忆组件上一次的渲染结果，在 props 没有变化时复用该结果，避免函数组件不必要的更新</strong>。</p><p><img src="images/image-20210830205522685.png" alt="image-20210830205522685" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830205522685.png" class="lozad post-image lozad post-image lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830205522685.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830205522685.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830205522685.png"></p><p>解释：</p><ul><li>React.memo 是一个高阶组件，用来记忆（memorize）组件。</li><li>参数（Child）：需要被记忆的组件，或者说是需要避免不必要更新的组件。</li><li>返回值（MemoChild）：React 记住的 Child 组件。</li></ul><p>原理：通过对比检查更新前后 props 是否相同，来决定是否复用上一次的渲染结果，</p><ul><li>如果相同，复用上一次的渲染结果；</li><li>如果不同，重新渲染组件。</li></ul><p><strong>并不是所有的组件都适合使用memo，比如child2组件，每次都需要重新渲染，使用memo反而会使性能变得更低，逻辑也变得更复杂</strong></p><h3 id="浅层对比"><a href="#浅层对比" class="headerlink" title="浅层对比"></a>浅层对比</h3><p>默认情况下，React.memo 只会对更新前后的 props 进行浅对比（shallow compare）与 PureComponent 相同。</p><p>也就是说，对于对象类型的 prop 来说，只会比较引用</p><ul><li>如果更新前后的引用相同，复用上一次的渲染结果（不会重新渲染该组件）。</li><li>如果更新前后的引用不同，重新渲染该组件。</li></ul><p>如果你要手动控制比较过程，可以使用 React.memo 的第二个参数：</p><p><img src="images/image-20210830220716165.png" alt="image-20210830220716165" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830220716165.png" class="lozad post-image lozad post-image lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830220716165.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830220716165.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830220716165.png"></p><p>解释：</p><ul><li>第二个参数：用来比较更新前后 props 的函数。</li><li>返回值：如果返回 true，表示记住（不重新渲染）该组件；如果返回 false，表示重新渲染该组件。</li></ul><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在使用 React.memo 时，对于对象类型的 props，只会比较引用（浅对比）。</p><p>但是，因为<strong>组件每次更新都会创建新的 props 值</strong>，比如，新的对象、事件处理程序等（函数组件的特性）。</p><p>这就导致：React.memo 在处理对象类型的 props 时，会失效（每次的 props 都是新对象）。</p><p>但是，我们还是想让 React.memo 在处理对象类型的 props 时，也有效。</p><p>为了让 React.memo 处理对象类型的 props 有效，只要在<em>组件更新期间保持对象类型引用相</em>等，就可以了。</p><p>这时候，就要用到以下两个 Hooks：</p><ul><li><code>useCallback</code> Hook：记住函数的引用，在组件每次更新时返回相同引用的函数。</li><li><code>useMemo</code> Hook：记住任意数据（数值、对象、函数等），在组件每次更新时返回相同引用的数据【功能之一】</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>使用场景：在使用 React.memo 时，为了组件每次更新时都能获取到相同引用的函数，就要用到 useCallback Hook</p><p>注意：<strong>需要配合 React.memo 高阶函数一起使用</strong>。</p><p>作用：记忆传入的回调函数，这个被记住的回调函数会一直生效，直到依赖项发生改变</p><p><img src="images/image-20210830230820580.png" alt="image-20210830230820580" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830230820580.png" class="lozad post-image lozad post-image lozad post-image lozad post-image" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830230820580.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830230820580.png" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210830230820580.png"></p><p>解释：</p><ul><li>第一个参数：必选，需要被记忆的回调函数。</li><li>第二个参数：必选，依赖项数组，用于指定回调函数中依赖（用到）的数据（类似于 useEffect 的第二个参数）。</li><li>即使没有依赖，也得传入空数组（[]），此时，useCallback 记住的回调函数就会一直生效。</li><li>返回值：useCallback 记住的回调函数。</li><li>useCallback 记住的回调函数会一直生效（或者说会一直返回同一个回调函数），直到依赖项发生改变。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hooks其他API&quot;&gt;&lt;a href=&quot;#Hooks其他API&quot; class=&quot;headerlink&quot; title=&quot;Hooks其他API&quot;&gt;&lt;/a&gt;Hooks其他API&lt;/h1&gt;&lt;h2 id=&quot;useRef-hook&quot;&gt;&lt;a href=&quot;#useRef-hoo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hooks基本使用</title>
    <link href="http://example.com/2023/04/24/02-hooks%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/04/24/02-hooks%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-24T11:16:07.082Z</published>
    <updated>2023-04-24T12:10:54.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Hooks基础"><a href="#React-Hooks基础" class="headerlink" title="React Hooks基础"></a>React Hooks基础</h1><ul><li>React Hooks 介绍 </li><li>React Hooks 基础</li></ul><h2 id="React-Hooks-介绍"><a href="#React-Hooks-介绍" class="headerlink" title="React Hooks 介绍"></a>React Hooks 介绍</h2><ol><li>Hooks 是什么</li><li>为什么要有 Hooks</li></ol><h3 id="Hooks-是什么"><a href="#Hooks-是什么" class="headerlink" title="Hooks 是什么"></a>Hooks 是什么</h3><ul><li><code>Hooks</code>：钩子、钓钩、钩住</li><li><code>Hooks</code> 是 <strong>React v16.8</strong> 中的新增功能 </li><li>作用：为<strong>函数组件</strong>提供状态、生命周期等原本 class 组件中提供的 React 功能<ul><li>可以理解为通过 Hooks 为函数组件钩入 class 组件的特性</li></ul></li><li>注意：<strong>Hooks 只能在函数组件中使用</strong>，自此，函数组件成为 React 的新宠儿</li></ul><p>React v16.8 版本前后，组件开发模式的对比：</p><ul><li>React v16.8 以前： class 组件(提供状态) + 函数组件(展示内容)</li><li>React v16.8 及其以后：<ol><li>class 组件(提供状态) + 函数组件(展示内容)</li><li>Hooks(提供状态) + 函数组件(展示内容)</li><li>混用以上两种方式：部分功能用 class 组件，部分功能用 Hooks+函数组件</li></ol></li></ul><p>注意1：虽然有了 Hooks，但 React 官方并没有计划从 React 库中移除 class。</p><p>注意2：有了 Hooks 以后，不能再把<strong>函数组件</strong>称为无状态组件了，因为 Hooks 为函数组件提供了状态。</p><h3 id="为什么要有-Hooks"><a href="#为什么要有-Hooks" class="headerlink" title="为什么要有 Hooks"></a>为什么要有 Hooks</h3><p>两个角度：1 组件的状态逻辑复用 2 class 组件自身的问题</p><ol><li><p>组件的状态逻辑复用：</p><ul><li>在 Hooks 之前，组件的状态逻辑复用经历了：mixins（混入）、HOCs（高阶组件）、render-props 等模式。</li><li>（早已废弃）mixins 的问题：1 数据来源不清晰 2 命名冲突。</li><li>HOCs、render-props 的问题：重构组件结构，导致组件形成 JSX 嵌套地狱问题。</li></ul></li><li><p>class 组件自身的问题：</p><ul><li>选择：函数组件和 class 组件之间的区别以及使用哪种组件更合适</li><li>需要理解 class 中的 this 是如何工作的</li><li>相互关联且需要对照修改的代码被拆分到不同生命周期函数中<ul><li>componentDidMount -&gt;  window.addEventListener(‘resize’, this.fn)</li><li>componentWillUnmount -&gt; window.addEventListener(‘resize’, this.fn)</li></ul></li></ul></li></ol><ul><li>相比于函数组件来说，不利于代码压缩和优化，也不利于 TS 的类型推导</li></ul><p>正是由于 React 原来存在的这些问题，才有了 Hooks 来解决这些问题</p><h3 id="hooks的优势"><a href="#hooks的优势" class="headerlink" title="hooks的优势"></a>hooks的优势</h3><p>由于原来 React 中存在的问题，促使 React 需要一个更好的自带机制来实现组件状态逻辑复用。</p><ol><li>Hooks 只能在函数组件中使用，避免了 class 组件的问题</li><li>复用组件状态逻辑，而无需更改组件层次结构</li><li>根据功能而不是基于生命周期方法强制进行代码分割</li><li>抛开 React 赋予的概念来说，Hooks 就是一些普通的函数</li><li>具有更好的 TS  类型推导</li><li>tree- - shaking  友 好，打包时去掉未引用的代码</li><li>更好的压 缩</li></ol><p>项目开发中，Hooks 的采用策略：</p><ul><li>不推荐直接使用 Hooks 大规模重构现有组件</li><li>推荐：新功能用 Hooks，复杂功能实现不了的，也可以继续用 class</li><li>找一个功能简单、非核心功能的组件开始使用 hooks</li></ul><h3 id="前面学习的-React-知识是有用的"><a href="#前面学习的-React-知识是有用的" class="headerlink" title="前面学习的 React 知识是有用的"></a>前面学习的 React 知识是有用的</h3><p>class 组件相关的 API 不用了，比如：</p><ul><li><code>class Hello extends Component</code></li><li><code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code></li><li><code>this</code> 相关的用法</li></ul><p>原来学习的内容还是要用的，比如：</p><ul><li>JSX：<code>&#123;&#125;</code>、<code>onClick=&#123;handleClick&#125;</code>、条件渲染、列表渲染、样式处理等</li><li>组件：函数组件、组件通讯</li><li>路由</li><li>React 开发理念：<code>单向数据流</code>、<code>状态提升</code> 等</li><li>解决问题的思路、技巧、常见错误的分析等上</li></ul><h2 id="useState-Hook"><a href="#useState-Hook" class="headerlink" title="useState Hook"></a>useState Hook</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>问题：Hook 是什么? 一个 Hook 就是一个特殊的函数，让你在函数组件中获取状态等 React 特性<br>使用模式：函数组件 + Hooks<br>特点：从名称上看，Hook 都以 use 开头</p><h3 id="useState-Hook-的基本使用"><a href="#useState-Hook-的基本使用" class="headerlink" title="useState Hook 的基本使用"></a>useState Hook 的基本使用</h3><ul><li>使用场景：当你想要在<strong>函数组件中，使用组件状态时</strong>，就要使用 <strong>useState</strong> Hook 了</li><li>作用：为函数组件提供状态（state）</li><li>使用步骤：<ol><li>导入 <code>useState</code> 函数</li><li>调用 <code>useState</code> 函数，并传入状态的初始值</li><li>从 <code>useState</code> 函数的返回值中，拿到状态和修改状态的函数</li><li>在 JSX 中展示状态</li><li>在按钮的点击事件中调用修改状态的函数，来更新状态</li></ol></li></ul><pre class="highlight"><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Count</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 返回值是一个数组</span></span><br><span class="line">  <span class="keyword">const</span> stateArray = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 状态值 -&gt; 0</span></span><br><span class="line">  <span class="keyword">const</span> state = stateArray[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 修改状态的函数</span></span><br><span class="line">  <span class="keyword">const</span> setState = stateArray[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 展示状态值 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>useState Hook -&gt; &#123;state&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 点击按钮，让状态值 +1 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setState(state + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre><ul><li>参数：<strong>状态初始值</strong>。比如，传入 0 表示该状态的初始值为 0<ul><li>注意：此处的状态可以是任意值（比如，数值、字符串等），而 class 组件中的 state 必须是对象</li></ul></li><li>返回值：数组，包含两个值：1 状态值（state） 2 修改该状态的函数（setState）</li></ul><h3 id="使用数组解构简化"><a href="#使用数组解构简化" class="headerlink" title="使用数组解构简化"></a>使用数组解构简化</h3><p>比如，要获取数组中的元素：</p><ol><li>原始方式：索引访问</li></ol><pre class="highlight"><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = arr[<span class="number">0</span>]  <span class="comment">// 获取索引为 0 的元素</span></span><br><span class="line"><span class="keyword">const</span> b = arr[<span class="number">1</span>]  <span class="comment">// 获取索引为 1 的元素</span></span><br></pre><ol start="2"><li>简化方式：数组解构<ul><li>相当于创建了两个变量（可以是任意的变量名称）分别获取到对应索引的数组元素</li></ul></li></ol><pre class="highlight"><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;aaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b] = arr</span><br><span class="line"><span class="comment">// a =&gt; arr[0]</span></span><br><span class="line"><span class="comment">// b =&gt; arr[1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [state, setState] = arr</span><br></pre><ul><li>使用数组解构简化 <code>useState</code> 的使用<ul><li>约定：<strong>修改状态的函数名称以 set 开头，后面跟上状态的名称</strong></li></ul></li></ul><pre class="highlight"><span class="line"><span class="comment">// 解构出来的名称可以是任意名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [age, setAge] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br></pre><h3 id="状态的读取和修改"><a href="#状态的读取和修改" class="headerlink" title="状态的读取和修改"></a>状态的读取和修改</h3><p>状态的使用：1 读取状态 2 修改状态</p><ol><li><p>读取状态：该方式提供的状态，是函数内部的局部变量，可以在函数内的任意位置使用</p></li><li><p>修改状态：</p></li></ol><ul><li><code>setCount(newValue)</code> 是一个函数，参数表示：<strong>新的状态值</strong></li><li>调用该函数后，将<strong>使用新的状态值<code>替换</code>旧值</strong></li><li>修改状态后，因为状态发生了改变，所以，该组件会重新渲染</li></ul><h3 id="组件的更新过程"><a href="#组件的更新过程" class="headerlink" title="组件的更新过程"></a>组件的更新过程</h3><p>函数组件使用 <strong>useState</strong> hook 后的执行过程，以及状态值的变化： </p><ul><li><p>组件第一次渲染：</p><ol><li>从头开始执行该组件中的代码逻辑</li><li>调用 <code>useState(0)</code> 将传入的参数作为状态初始值，即：0</li><li>渲染组件，此时，获取到的状态 count 值为： 0</li></ol></li><li><p>组件第二次渲染：</p><ol><li>点击按钮，调用 <code>setCount(count + 1)</code> 修改状态，因为状态发生改变，所以，该组件会重新渲染</li><li>组件重新渲染时，会再次执行该组件中的代码逻辑</li><li>再次调用 <code>useState(0)</code>，此时 <strong>React 内部会拿到最新的状态值而非初始值</strong>，比如，该案例中最新的状态值为 1</li><li>再次渲染组件，此时，获取到的状态 count 值为：1</li></ol></li></ul><p>注意：<strong>useState 的初始值(参数)只会在组件第一次渲染时生效</strong>。 </p><p>也就是说，以后的每次渲染，useState 获取到都是最新的状态值。React 组件会记住每次最新的状态值!</p><h3 id="为函数组件添加多个状态"><a href="#为函数组件添加多个状态" class="headerlink" title="为函数组件添加多个状态"></a>为函数组件添加多个状态</h3><p>问题：如果一个函数组件需要多个状态，该如何处理?<br>回答：调用 <code>useState</code> Hook 多次即可，每调用一次 useState Hook 可以提供一个状态。<br>注意：useState Hook 多次调用返回的 [state, setState] 相互之间，互不影响。</p><h3 id="hooks-的使用规则"><a href="#hooks-的使用规则" class="headerlink" title="hooks 的使用规则"></a>hooks 的使用规则</h3><p>注意：<strong>React Hooks 只能直接出现在 函数组件 中，不能嵌套在 if/for/其他函数中</strong>！</p><p>否则就会报错：React Hook “useState” is called conditionally. React Hooks must be called in the exact same order in every component render</p><p>React 的 useState 这个 Hook 被条件性（放在一个条件判断中）的调用了。</p><p>React Hooks 必须要每次组件渲染时，按照<strong>相同的顺序</strong>来调用所有的 Hooks。</p><ul><li>为什么会有这样的规则？ 因为 React 是按照 Hooks 的调用顺序来识别每一个 Hook，如果每次调用的顺序不同，导致 React 无法知道是哪一个 Hook</li><li>通过开发者工具可以查看到。</li></ul><h2 id="useEffect-Hook"><a href="#useEffect-Hook" class="headerlink" title="useEffect Hook"></a>useEffect Hook</h2><ol><li>side effect - 副作用</li><li>useEffect 的基本使用</li><li>useEffect 的依赖</li><li>useEffect 发送请求</li></ol><h3 id="side-effect-副作用"><a href="#side-effect-副作用" class="headerlink" title="side effect - 副作用"></a>side effect - 副作用</h3><p>使用场景：当你想要在函数组件中，<strong>处理副作用（side effect）时</strong>，就要使用 <strong>useEffect</strong> Hook 了<br>作用：<strong>处理函数组件中的副作用（side effect）</strong></p><p>问题：副作用（side effect）是什么?<br>回答：在计算机科学中，如果一个函数或其他操作修改了其局部环境之外的状态变量值，那么它就被称为有副作用<br>类比，对于 999 感冒灵感冒药来说：</p><ul><li>（<strong>主</strong>）作用：用于感冒引起的头痛，发热，鼻塞，流涕，咽痛等 </li><li>副作用：可见困倦、嗜睡、口渴、虚弱感</li></ul><p>理解：副作用是相对于主作用来说的，一个功能（比如，函数）除了主作用，其他的作用就是副作用<br>对于 React 组件来说，<strong>主作用就是根据数据（state/props）渲染 UI</strong>，除此之外都是副作用（比如，手动修改 DOM）</p><p>React 组件的公式：<strong>UI = f(state)</strong></p><p>常见的副作用（side effect）</p><ul><li>数据（Ajax）请求、手动修改 DOM、localStorage 操作等</li></ul><h3 id="useEffect-的基本使用"><a href="#useEffect-的基本使用" class="headerlink" title="useEffect 的基本使用"></a>useEffect 的基本使用</h3><p>使用场景：当你想要在函数组件中，处理副作用（side effect）时，就要使用 useEffect Hook 了<br>作用：处理函数组件中的副作用（side effect）<br>注意：在实际开发中，副作用是不可避免的。因此，react 专门提供了 <strong>useEffect</strong> Hook <strong>来处理函数组件中的副作用</strong></p><pre class="highlight"><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`当前已点击 <span class="subst">$&#123;count&#125;</span> 次`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`当前已点击 <span class="subst">$&#123;count&#125;</span> 次`</span></span><br><span class="line">&#125;)</span><br></pre><p>解释：</p><ul><li>参数：回调函数（称为 <strong>effect</strong>），就是<strong>在该函数中写副作用代码</strong></li><li>执行时机：该 effect 会在组件渲染后以及组件更新后执行</li><li>相当于componentDidMount + componentDidUpdate</li></ul><h3 id="useEffect-的依赖"><a href="#useEffect-的依赖" class="headerlink" title="useEffect 的依赖"></a>useEffect 的依赖</h3><ul><li>问题：如果组件中有另外一个状态，另一个状态更新时，刚刚的 effect 回调，也会执行 </li><li>性能优化：<strong>跳过不必要的执行，只在 count 变化时，才执行相应的 effect</strong></li></ul><pre class="highlight"><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`当前已点击 <span class="subst">$&#123;count&#125;</span> 次`</span></span><br><span class="line">&#125;, [count])</span><br></pre><p>解释：</p><ul><li>第二个参数：可选的，可省略；也可以传一个数组，数组中的元素可以成为依赖项（deps） </li><li>该示例中表示：只有当 count 改变时，才会重新执行该 effect</li></ul><h3 id="useEffect-的依赖是一个空数组"><a href="#useEffect-的依赖是一个空数组" class="headerlink" title="useEffect 的依赖是一个空数组"></a>useEffect 的依赖是一个空数组</h3><p>useEffect 的第二个参数，还可以是一个<strong>空数组（[]）</strong>，表示只在组件第一次渲染后执行 effect<br>使用场景：1 事件绑定 2 发送请求获取数据 等</p><pre class="highlight"><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line">&#125;, [])</span><br></pre><p>解释：</p><ul><li>该 effect 只会在组件第一次渲染后执行，因此，可以执行像事件绑定等只需要执行一次的操作<ul><li>此时，相当于 class 组件的 componentDidMount 钩子函数的作用</li></ul></li><li>跟 useState Hook 一样，一个组件中也可以调用 useEffect Hook 多次 </li><li>推荐：一个 useEffect 只处理一个功能，有多个功能时，使用多次 useEffect</li></ul><h3 id="总结-useEffect-的使用"><a href="#总结-useEffect-的使用" class="headerlink" title="总结 useEffect 的使用"></a>总结 useEffect 的使用</h3><pre class="highlight"><span class="line"><span class="comment">// 触发时机：1 第一次渲染会执行 2 每次组件重新渲染都会再次执行</span></span><br><span class="line"><span class="comment">// componentDidMount + ComponentDidUpdate</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentDidMount</span></span><br><span class="line"><span class="comment">// 触发时机：只在组件第一次渲染时执行</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// componentDidMount + componentDidUpdate(判断)</span></span><br><span class="line"><span class="comment">// 触发时机：1 第一次渲染会执行 2 当 count 变化时会再次执行</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;&#125;, [count])</span><br></pre><h3 id="不要对useEffect的依赖项撒谎"><a href="#不要对useEffect的依赖项撒谎" class="headerlink" title="不要对useEffect的依赖项撒谎"></a>不要对useEffect的依赖项撒谎</h3><pre class="highlight"><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;点击了&#x27;</span> + count + <span class="string">&#x27;次&#x27;</span></span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>计数器：&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre><blockquote><p>useEffect完全指南：<a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></p></blockquote><h3 id="useEffect-清理副作用"><a href="#useEffect-清理副作用" class="headerlink" title="useEffect 清理副作用"></a>useEffect 清理副作用</h3><p>有时候，我们只想<strong>在 React 更新 DOM 之后运行一些额外的代码。</strong>比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。</p><p>还有一些副作用是需要清除的。例如<strong>订阅外部数据源， 开启定时器，注册事件</strong>。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p><p>问题：如何在组件卸载时，解绑事件？此时，就用到 effect 的返回值了</p><pre class="highlight"><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line">&#125;, [])</span><br></pre><p>解释：</p><ul><li>effect 的返回值也是可选的，可省略。也可以返回一个清理函数，用来执行事件解绑等清理操作</li><li>清理函数的执行时机：1 组件卸载时 2 effect 重新执行前 <ul><li>此时，相当于 class 组件的 componentWillUnmount 钩子函数的作用</li></ul></li><li>推荐：一个 useEffect 只处理一个功能，有多个功能时，使用多次 useEffect </li><li>优势：根据业务逻辑来拆分，相同功能的业务逻辑放在一起，而不是根据生命周期方法名称来拆分代码 </li><li>编写代码时，关注点集中；而不是上下翻滚来查看代码</li></ul><h3 id="将事件处理程序放在-useEffect-内部"><a href="#将事件处理程序放在-useEffect-内部" class="headerlink" title="将事件处理程序放在 useEffect 内部"></a>将事件处理程序放在 useEffect 内部</h3><pre class="highlight"><span class="line"><span class="comment">// 1 将 resize 事件处理程序放在 effect 回调中，当前这个代码是没有问题的</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window 窗口大小改变了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 将 resize 事件处理程序拿到 useEffect 的外部，当前这个代码是没有问题的</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window 窗口大小改变了&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 有依赖项的情况：</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resize 事件的处理程序</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window 窗口大小改变了&#x27;</span>, count)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [count])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：此处的代码，会给一些警告！！！ 不要按照这种方式写代码！！！</span></span><br><span class="line"><span class="comment">// 4 如果将 handleResize 放到了 useEffect 外部，React 会给以警告：</span></span><br><span class="line"><span class="comment">//   要么将 handleResize 放到 useEffect 中</span></span><br><span class="line"><span class="comment">//   要么使用 useCallback 这个 hook 来包裹 handleResize</span></span><br><span class="line"><span class="comment">// resize 事件的处理程序</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleResize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;window 窗口大小改变了&#x27;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;useeffect 执行了&#x27;</span>)</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [handleResize])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结以上几种情况，推荐：在给 window 绑定事件时，将 事件处理程序放在 useEffect 内部。</span></span><br></pre><h3 id="useEffect-发送请求"><a href="#useEffect-发送请求" class="headerlink" title="useEffect 发送请求"></a>useEffect 发送请求</h3><p>在组件中，使用 useEffect Hook 发送请求获取数据（side effect）：</p><pre class="highlight"><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">loadData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="title function_">loadData</span>()</span><br><span class="line">&#125;, [])</span><br></pre><p>解释：</p><ul><li>注意：<strong>effect 只能是一个同步函数，不能使用 async</strong></li><li>因为 effect 的返回值应该是一个清理函数，React 会在组件卸载或者 effect 的依赖项变化时重新执行 </li><li>但如果 effect 是 async 的，此时返回值是 Promise 对象。这样的话，就无法保证清理函数被立即调用</li><li>如果延迟调用清理函数，也就没有机会忽略过时的请求结果或取消请求</li><li><strong>为了使用 async/await 语法，可以在 effect 内部创建 async 函数，并调用</strong></li></ul><pre class="highlight"><span class="line"><span class="comment">// 错误演示：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要给 effect 添加 async</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="keyword">async</span> () =&gt; &#123;&#125;, [])</span><br></pre><pre class="highlight"><span class="line"><span class="comment">// https://github.com/facebook/react/issues/14326#issuecomment-441680293</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 是否取消本次请求</span></span><br><span class="line">  <span class="keyword">let</span> didCancel = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchMyAPI</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">&#x27;http://something/&#x27;</span> + productId</span><br><span class="line">    <span class="keyword">let</span> config = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">myFetch</span>(url)</span><br><span class="line">    <span class="comment">// 如果开启其他请求，就忽略本次（过时）的请求结果</span></span><br><span class="line">    <span class="keyword">if</span> (!didCancel) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetchMyAPI</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; didCancel = <span class="literal">true</span> &#125; <span class="comment">// 取消本次请求</span></span><br><span class="line">&#125;, [productId])</span><br></pre><h3 id="useEffect循环报错问题"><a href="#useEffect循环报错问题" class="headerlink" title="useEffect循环报错问题"></a>useEffect循环报错问题</h3><pre class="highlight"><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getList</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://geek.itheima.net/v1_0/channels&#x27;</span>)</span><br><span class="line">    <span class="title function_">setList</span>(res.<span class="property">data</span>.<span class="property">data</span>.<span class="property">channels</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(list)</span><br><span class="line">  <span class="title function_">getList</span>()</span><br><span class="line">&#125;, [list])</span><br><span class="line"></span><br></pre><h2 id="自定义hooks"><a href="#自定义hooks" class="headerlink" title="自定义hooks"></a>自定义hooks</h2><p>除了使用内置的 Hooks 之外，还可以创建自己的 Hooks（自定义 Hooks）。</p><p>使用场景：<strong>将组件状态逻辑提取到可重用的函数（自定义 Hooks）中，实现状态逻辑复用。</strong></p><p>内置 Hooks 为函数组件赋予了 class 组件的功能；在此之上，自定义 Hooks 针对不同组件实现不同状态逻辑复用。</p><ul><li><p>自定义 Hooks 是一个函数，<strong>约定函数名称必须以 use 开头，React 就是通过函数名称是否以 use 开头来判断是不是 Hooks</strong></p></li><li><p>Hooks 只能在函数组件中或其他自定义 Hooks 中使用，否则，会报错！</p></li><li><p>自定义 Hooks 用来提取组件的状态逻辑，根据不同功能可以有不同的参数和返回值（就像使用普通函数一样）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React-Hooks基础&quot;&gt;&lt;a href=&quot;#React-Hooks基础&quot; class=&quot;headerlink&quot; title=&quot;React Hooks基础&quot;&gt;&lt;/a&gt;React Hooks基础&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;React Hooks 介绍 &lt;/li&gt;</summary>
      
    
    
    
    <category term="hooks" scheme="http://example.com/categories/hooks/"/>
    
    
  </entry>
  
  <entry>
    <title>组件复用的说明</title>
    <link href="http://example.com/2023/04/24/01-react-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/2023/04/24/01-react-%E7%BB%84%E4%BB%B6%E5%A4%8D%E7%94%A8/</id>
    <published>2023-04-24T11:16:07.073Z</published>
    <updated>2023-04-24T12:14:47.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mixins（已废弃）"><a href="#mixins（已废弃）" class="headerlink" title="mixins（已废弃）"></a>mixins（已废弃）</h1><blockquote><p><a href="https://react.docschina.org/blog/2016/07/13/mixins-considered-harmful.html">https://react.docschina.org/blog/2016/07/13/mixins-considered-harmful.html</a></p></blockquote><ul><li>mixin引入了隐式依赖关系<ul><li>对于组件中的方法和数据的来源不明确，不容易维护</li></ul></li><li>Mixins 导致名称冲突</li><li>Mixins 导致滚雪球般的复杂性</li></ul><h1 id="render-props技术"><a href="#render-props技术" class="headerlink" title="render-props技术"></a>render-props技术</h1><h2 id="组件复用的说明"><a href="#组件复用的说明" class="headerlink" title="组件复用的说明"></a>组件复用的说明</h2><ul><li>思考：如果两个组件中的部分功能相似或相同，该如何处理？</li><li>处理方式：复用相似的功能（联想函数封装）</li><li>复用什么？1. state 2. 操作state的方法   <strong>复用组件的状态和组件的逻辑，组件的UI不一样</strong></li><li>两种解决方案<ul><li>render-props</li><li>HOC（高阶组件）</li><li>hooks</li></ul></li><li>注意：这两种方式不是新的API，而是利用React自身特点的编码技巧，演化而成的固定模式（写法）</li></ul><h2 id="render-props基本使用"><a href="#render-props基本使用" class="headerlink" title="render-props基本使用"></a>render-props基本使用</h2><ul><li><p>思路：将要复用的state和操作state的方法封装到一个组件中</p></li><li><p>问题：渲染的UI内容不一样，该怎么办</p></li><li><p><strong>在使用组件时，添加一个值为函数的prop，通常把这个prop命名为render，在组件内部调用这个函数。传进来的函数负责渲染UI</strong></p></li><li><p>问题2：如果获取组件内部的状态</p></li><li><p><strong>在组件内部调用方法的时候，把状态当成参数进行传递</strong></p></li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"><span class="comment">// … 省略state和操作state的方法</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">render</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><pre class="highlight"><span class="line">&lt;<span class="title class_">Mouse</span> render=&#123;<span class="function">(<span class="params">mouse</span>) =&gt;</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标当前位置 &#123;mouse.x&#125;，&#123;mouse.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">)&#125;/&gt;</span><br></pre><h2 id="children代替render属性"><a href="#children代替render属性" class="headerlink" title="children代替render属性"></a>children代替render属性</h2><ul><li>注意：并不是该模式叫 render props 就必须使用名为render的prop，实际上可以使用任意名称的prop</li><li>把prop是一个函数并且告诉组件要渲染什么内容的技术叫做：render props模式</li><li>推荐：使用 children 代替 render 属性</li></ul><pre class="highlight"><span class="line">&lt;<span class="title class_">Mouse</span>&gt;</span><br><span class="line">&#123;<span class="function">(<span class="params">&#123;x, y&#125;</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标的位置是 &#123;x&#125;，&#123;y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span> &#125;</span><br><span class="line">&lt;/<span class="title class_">Mouse</span>&gt;</span><br><span class="line"><span class="comment">// 组件内部：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">children</span>(<span class="variable language_">this</span>.<span class="property">state</span>)</span><br></pre><pre class="highlight"><span class="line"><span class="comment">// Context 中的用法：</span></span><br><span class="line">&lt;<span class="title class_">Consumer</span>&gt;</span><br><span class="line">&#123;<span class="function"><span class="params">data</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>data参数表示接收到的数据 -- &#123;data&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">&lt;/<span class="title class_">Consumer</span>&gt;</span><br></pre><h2 id="render-props优化"><a href="#render-props优化" class="headerlink" title="render-props优化"></a>render-props优化</h2><ul><li>推荐：给 render props 模式添加 props校验</li><li>应该在组件卸载时解除 mousemove 事件绑定</li></ul><pre class="highlight"><span class="line"><span class="title class_">Mouse</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">chidlren</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;</span><br></pre><pre class="highlight"><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">&#125;</span><br></pre><p>封装一个组件，用于提取公共的状态和逻辑，比如鼠标的位置以及鼠标位置的更新，渲染的内容是不确定的，让组件接受一个叫children的prop，而且children必须是一个函数</p><h1 id="高阶组件-HOC-higher-order-component"><a href="#高阶组件-HOC-higher-order-component" class="headerlink" title="高阶组件  HOC higher order component"></a>高阶组件  HOC higher order component</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>目的：实现状态逻辑复用   增强一个组件的能力</p></li><li><p>采用 包装（装饰）模式 ，比如说：手机壳</p></li><li><p>手机：获取保护功能</p></li><li><p>手机壳 ：提供保护功能</p></li><li><p>高阶组件就相当于手机壳，通过包装组件，增强组件功能</p></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/HOC.png" class="lozad post-image"src="images/HOC.png"></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><ul><li>高阶组件（HOC，Higher-Order Component）是一个函数，接收要包装的组件，返回增强后的组件</li><li>高阶组件的命名： <code>withMouse</code>  <code>withRouter</code> <code>withXXX</code></li><li>高阶组件内部创建一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给<br>被包装组件 </li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> <span class="title class_">CatWithMouse</span> = <span class="title function_">withMouse</span>(<span class="title class_">Cat</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PositionWithMOuse</span> = <span class="title function_">withMouse</span>(<span class="title class_">Position</span>)</span><br></pre><pre class="highlight"><span class="line"><span class="comment">// 高阶组件内部创建的类组件：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">WithMouse</span> = (<span class="params">Base</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">        <span class="comment">// 处理鼠标的位置等操作</span></span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Base</span> &#123;<span class="attr">...this.state</span>&#125; /&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Mouse</span></span><br><span class="line">&#125;</span><br></pre><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li>创建一个函数，名称约定以 with 开头</li><li>指定函数参数（作为要增强的组件）  传入的组件只能渲染基本的UI</li><li>在函数内部创建一个类组件，<strong>提供复用的状态逻辑代码</strong>，并返回</li><li>在内部创建的组件的render中，需要渲染传入的基本组件，增强功能，通过props的方式给基本组件传值</li><li>调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面中</li></ul><pre class="highlight"><span class="line"><span class="comment">// 创建组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MousePosition</span> = <span class="title function_">withMouse</span>(<span class="title class_">Position</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染组件</span></span><br><span class="line">&lt;<span class="title class_">MousePosition</span> /&gt;</span><br></pre><h2 id="传递props"><a href="#传递props" class="headerlink" title="传递props"></a>传递props</h2><ul><li>问题：props丢失</li><li>原因：高阶组件没有往下传递props</li><li>解决方式：渲染 WrappedComponent 时，将 state 和 this.props 一起传递给组件</li><li>传递方式：</li></ul><pre class="highlight"><span class="line">&lt;<span class="title class_">WrappedComponent</span> &#123;...<span class="variable language_">this</span>.<span class="property">state</span>&#125; &#123;...<span class="variable language_">this</span>.<span class="property">props</span>&#125; /&gt;</span><br></pre><h1 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mixins（已废弃）&quot;&gt;&lt;a href=&quot;#mixins（已废弃）&quot; class=&quot;headerlink&quot; title=&quot;mixins（已废弃）&quot;&gt;&lt;/a&gt;mixins（已废弃）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://reac</summary>
      
    
    
    
    <category term="hooks" scheme="http://example.com/categories/hooks/"/>
    
    
  </entry>
  
  <entry>
    <title>react路由</title>
    <link href="http://example.com/2023/04/24/06-react%E8%B7%AF%E7%94%B1/"/>
    <id>http://example.com/2023/04/24/06-react%E8%B7%AF%E7%94%B1/</id>
    <published>2023-04-24T11:14:22.865Z</published>
    <updated>2023-04-24T12:15:22.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由基本介绍"><a href="#路由基本介绍" class="headerlink" title="路由基本介绍"></a>路由基本介绍</h1><p>现代的前端应用大多都是 SPA（单页应用程序），也就是只有一个 HTML 页面的应用程序。因为它的用户体验更好、对服务器的压力更小，所以更受欢迎。为了有效的使用单个页面来管理原来多页面的功能，前端路由应运而生。</p><ul><li>前端路由的功能：让用户从一个视图（页面）导航到另一个视图（页面）</li><li>前端路由是一套映射规则，在React中，是 URL路径 与 组件 的对应关系  </li><li>使用React路由简单来说，就是配置 路径和组件（配对）</li></ul><ul><li>想要实现单页应用程序（SPA），就必须使用到路由  react-router</li><li>官网：<a href="https://reacttraining.com/react-router/">react-router</a></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%8D%95%E9%A1%B5%E9%9D%A2.png" class="lozad post-image"src="images/%E5%8D%95%E9%A1%B5%E9%9D%A2.png"></p><h1 id="路由基本使用"><a href="#路由基本使用" class="headerlink" title="路由基本使用"></a>路由基本使用</h1><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>安装</li></ul><pre class="highlight"><span class="line">yarn add react-router-dom</span><br></pre><ul><li><code>react-router-dom</code>这个包提供了三个核心的组件</li></ul><pre class="highlight"><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span>, <span class="title class_">Route</span>, <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br></pre><ul><li>使用<code>HashRouter</code>包裹整个应用，一个项目中只会有一个Router</li></ul><pre class="highlight"><span class="line">&lt;<span class="title class_">Router</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    // … 省略页面内容</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Router</span>&gt;</span><br></pre><ul><li>使用Link指定导航链接</li></ul><pre class="highlight"><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">&quot;/first&quot;</span>&gt;页面一&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/two&quot;</span>&gt;</span>页面二<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br></pre><ul><li>使用<code>Route</code>指定路由规则</li></ul><pre class="highlight"><span class="line"><span class="comment">// 在哪里写的Route,最终匹配到的组件就会渲染到这</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/first&quot;</span> component=&#123;<span class="title class_">First</span>&#125;&gt;&lt;/<span class="title class_">Route</span>&gt;</span><br></pre><h2 id="Router详细说明"><a href="#Router详细说明" class="headerlink" title="Router详细说明"></a>Router详细说明</h2><ul><li><p>Router 组件：包裹整个应用，一个 React 应用只需要使用一次</p></li><li><p>两种常用 Router：<code>HashRouter</code> 和 <code>BrowserRouter</code></p></li><li><p>HashRouter：使用 URL 的哈希值实现（<code>localhost:3000/#/first</code>）</p></li><li><p>BrowserRouter：使用 H5 的 history API 实现（<code>localhost:3000/first</code>）</p></li></ul><p>最佳实践</p><pre class="highlight"><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HashRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br></pre><h2 id="Link与NavLink"><a href="#Link与NavLink" class="headerlink" title="Link与NavLink"></a>Link与NavLink</h2><p><code>Link</code>组件最终会渲染成a标签，用于指定路由导航</p><ul><li>to属性，将来会渲染成a标签的href属性</li><li><code>Link</code>组件无法实现导航的高亮效果</li></ul><p><code>NavLink</code>组件，一个更特殊的<code>Link</code>组件，可以用用于指定当前导航高亮</p><ul><li>to属性，用于指定地址，会渲染成a标签的href属性</li><li>activeClass: 用于指定高亮的类名，默认<code>active</code></li><li>exact: 精确匹配，表示必须精确匹配类名才生效</li></ul><h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><ul><li>path 的说明<ul><li>默认情况下，/能够匹配任意/开始的路径</li><li>如果 path 的路径匹配上了，那么就可以对应的组件就会被 render</li><li>如果 path 没有匹配上，那么会 render null</li><li>如果没有指定 path，那么一定会被渲染</li></ul></li><li>exact 的说明， exact 表示精确匹配某个路径<ul><li>一般来说，如果路径配置了 /， 都需要配置 exact 属性</li></ul></li></ul><h2 id="Switch与404"><a href="#Switch与404" class="headerlink" title="Switch与404"></a>Switch与404</h2><ul><li><p>通常，我们会把<code>Route</code>包裹在一个<code>Switch</code>组件中</p></li><li><p>在<code>Switch</code>组件中，不管有多少个路由规则匹配到了，都只会渲染第一个匹配的组件</p></li><li><p>通过<code>Switch</code>组件非常容易的就能实现404错误页面的提示</p></li></ul><pre class="highlight"><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">component</span>=<span class="string">&#123;User&#125;/</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;NoMatch&#125;/</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre><h1 id="嵌套路由的配置"><a href="#嵌套路由的配置" class="headerlink" title="嵌套路由的配置"></a>嵌套路由的配置</h1><ul><li><p>在React中，配置嵌套路由非常的简单，因为<code>Route</code>就是一个组件，可以在任意想配置的地方进行配置</p></li><li><p>但是配置嵌套路由的时候，需要对路径进行处理，必须要先匹配到父级路由，才能匹配到子路由</p></li></ul><pre class="highlight"><span class="line"><span class="comment">// 通过/home可以匹配Home父组件  再通过/list匹配子组件</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/home/list&quot;</span> component=&#123;<span class="title class_">List</span>&#125; /&gt;</span><br></pre><h1 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h1><ul><li> 场景：点击登录按钮，登录成功后，通过代码跳转到后台首页，如何实现？</li><li> 编程式导航：通过 JS 代码来实现页面跳转</li><li> history 是 React 路由提供的，用于获取浏览器历史记录的相关信息</li><li> push(path)：跳转到某个页面，参数 path 表示要跳转的路径</li><li> go(n)： 前进或后退到某个页面，参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页）</li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Login</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    handleLogin = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="string">&#x27;/home&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;...省略其他代码&#125;</span><br><span class="line">&#125;</span><br></pre><h1 id="动态路由与路由参数获取"><a href="#动态路由与路由参数获取" class="headerlink" title="动态路由与路由参数获取"></a>动态路由与路由参数获取</h1><ul><li>可以使用<code>:id</code>的方式来配置动态的路由参数</li></ul><pre class="highlight"><span class="line"><span class="comment">// 可以匹配 /users/1  /users/2  /users/xxx</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/users/:id&quot;</span> component=&#123;<span class="title class_">Users</span>&#125; /&gt;</span><br></pre><ul><li>在组件中，通过<code>props</code>可以接收到路由的参数</li></ul><pre class="highlight"><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">match</span>.<span class="property">params</span>)</span><br><span class="line">&#125;</span><br></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;路由基本介绍&quot;&gt;&lt;a href=&quot;#路由基本介绍&quot; class=&quot;headerlink&quot; title=&quot;路由基本介绍&quot;&gt;&lt;/a&gt;路由基本介绍&lt;/h1&gt;&lt;p&gt;现代的前端应用大多都是 SPA（单页应用程序），也就是只有一个 HTML 页面的应用程序。因为它的用户体验更</summary>
      
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>react原理揭秘</title>
    <link href="http://example.com/2023/04/24/05-react%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98/"/>
    <id>http://example.com/2023/04/24/05-react%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98/</id>
    <published>2023-04-24T11:14:22.850Z</published>
    <updated>2023-04-24T12:15:17.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h1><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><ul><li>setState() 是异步更新数据的</li><li>注意：使用该语法时，后面的 setState() 不要依赖于前面的 setState()</li></ul><pre class="highlight"><span class="line"><span class="number">1.</span> 当你调用 setState 的时候，<span class="title class_">React</span>.<span class="property">js</span> 并不会马上修改 state （为什么）</span><br><span class="line"><span class="number">2.</span> 而是把这个对象放到一个更新队列里面</span><br><span class="line"><span class="number">3.</span> 稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。</span><br></pre><ul><li>可以多次调用 setState() ，只会触发一次重新渲染</li></ul><pre class="highlight"><span class="line"><span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line"><span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 1</span></span><br></pre><p>在使用 React.js 的时候，并不需要担心多次进行 <code>setState</code> 会带来性能问题。</p><h2 id="推荐语法"><a href="#推荐语法" class="headerlink" title="推荐语法"></a>推荐语法</h2><ul><li><p> 推荐：使用 <code>setState((preState) =&gt; &#123;&#125;)</code> 语法</p></li><li><p> 参数preState: React.js 会把上一个 <code>setState</code> 的结果传入这个函数</p></li></ul><pre class="highlight"><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">preState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: preState.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 1</span></span><br></pre><p><strong>这种语法依旧是异步的，但是state可以获取到最新的状态，适用于需要调用多次setState</strong></p><h2 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h2><ul><li>场景：在状态更新（页面完成重新渲染）后立即执行某个操作</li><li> 语法：<code>setState(updater[, callback])</code></li></ul><pre class="highlight"><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line"><span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;&#125;),</span><br><span class="line"><span class="function">() =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这个回调函数会在状态更新后立即执行&#x27;</span>)&#125;</span><br><span class="line">)</span><br></pre><pre class="highlight"><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line"><span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line"><span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;更新state后的标题：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre><h1 id="组件更新机制"><a href="#组件更新机制" class="headerlink" title="组件更新机制"></a>组件更新机制</h1><ul><li> setState() 的两个作用： 1. 修改 state 2. 更新组件（UI）</li><li>过程：父组件重新渲染时，也会重新渲染子组件。但只会渲染当前组件子树（当前组件及其所有子组件）</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0.png" class="lozad post-image"src="images/%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0.png"> </p><h1 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h1><ol><li>功能第一</li><li>性能优化</li></ol><h2 id="减轻state"><a href="#减轻state" class="headerlink" title="减轻state"></a>减轻state</h2><ul><li>减轻 state：只存储跟组件渲染相关的数据（比如：count / 列表数据 / loading 等）</li><li>注意：不用做渲染的数据不要放在 state 中，比如定时器 id等 </li><li>对于这种需要在多个方法中用到的数据，应该直接放在 this 中 <ul><li>this.xxx = ‘bbb’</li><li>this.xxx</li></ul></li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// timerId存储到this中，而不是state中</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">timerId</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerId</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre><p>vue中不要把和渲染无关的数据放到data中</p><h2 id="避免不必要的重新渲染"><a href="#避免不必要的重新渲染" class="headerlink" title="避免不必要的重新渲染"></a>避免不必要的重新渲染</h2><ul><li><p> 组件更新机制：父组件更新会引起子组件也被更新，这种思路很清晰</p></li><li><p>问题：子组件没有任何变化时也会重新渲染 （接收到的props没有发生任何的改变）</p></li><li><p>如何避免不必要的重新渲染呢？</p></li><li><p> 解决方式：使用钩子函数 <code>shouldComponentUpdate(nextProps, nextState)</code></p></li><li><p> 作用：通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染</p></li><li><p>触发时机：更新阶段的钩子函数，组件重新渲染前执行 （shouldComponentUpdate =&gt; render）</p></li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 根据条件，决定是否重新渲染组件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;…&#125;</span><br><span class="line">&#125;</span><br></pre><p> 案例：随机数</p><h2 id="纯组件"><a href="#纯组件" class="headerlink" title="纯组件"></a>纯组件</h2><ul><li>纯组件：<code>React.PureComponent</code> 与 <code>React.Component </code>功能相似</li><li>区别：PureComponent 内部自动实现了 shouldComponentUpdate 钩子，不需要手动比较</li><li>原理：纯组件内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件</li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>纯组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><p><strong>只有在性能优化的时候可能会用到纯组件，不要所有的组件都使用纯组件，因为纯组件需要消耗性能进行对比</strong></p><h2 id="纯组件比较-值类型"><a href="#纯组件比较-值类型" class="headerlink" title="纯组件比较-值类型"></a>纯组件比较-值类型</h2><ul><li><p>说明：纯组件内部的对比是 shallow compare（浅层对比）</p></li><li><p> 对于值类型来说：比较两个值是否相同（直接赋值即可，没有坑）</p></li></ul><pre class="highlight"><span class="line"><span class="keyword">let</span> number = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> newNumber = number</span><br><span class="line">newNumber = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number === newNumber) <span class="comment">// false</span></span><br></pre><pre class="highlight"><span class="line">state = &#123; <span class="attr">number</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">number</span>: <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// PureComponent内部对比：</span></span><br><span class="line">最新的state.<span class="property">number</span> === 上一次的state.<span class="property">number</span> <span class="comment">// false，重新渲染组件</span></span><br></pre><h2 id="纯组件比较-引用类型"><a href="#纯组件比较-引用类型" class="headerlink" title="纯组件比较-引用类型"></a>纯组件比较-引用类型</h2><ul><li>说明：纯组件内部的对比是 shallow compare（浅层对比）</li><li>对于引用类型来说：只比较对象的引用（地址）是否相同</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">number</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">const</span> newObj = obj</span><br><span class="line">newObj.<span class="property">number</span> = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj === obj) <span class="comment">// true</span></span><br></pre><pre class="highlight"><span class="line">state = &#123; <span class="attr">obj</span>: &#123; <span class="attr">number</span>: <span class="number">0</span> &#125; &#125;</span><br><span class="line"><span class="comment">// 错误做法</span></span><br><span class="line">state.<span class="property">obj</span>.<span class="property">number</span> = <span class="number">2</span></span><br><span class="line"><span class="title function_">setState</span>(&#123; <span class="attr">obj</span>: state.<span class="property">obj</span> &#125;)</span><br><span class="line"><span class="comment">// PureComponent内部比较：</span></span><br><span class="line">最新的state.<span class="property">obj</span> === 上一次的state.<span class="property">obj</span> <span class="comment">// true，不重新渲染组件</span></span><br></pre><p>纯组件的最佳实践：</p><p> 注意：state 或 props 中属性值为引用类型时，应该创建新数据，不要直接修改原数据！</p><pre class="highlight"><span class="line"><span class="comment">// 正确！创建新数据</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123;...state.<span class="property">obj</span>, <span class="attr">number</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="title function_">setState</span>(&#123; <span class="attr">obj</span>: newObj &#125;)</span><br><span class="line"><span class="comment">// 正确！创建新数据</span></span><br><span class="line"><span class="comment">// 不要用数组的push / unshift 等直接修改当前数组的的方法</span></span><br><span class="line"><span class="comment">// 而应该用 concat 或 slice 等这些返回新数组的方法</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line"><span class="attr">list</span>: [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>, &#123;新数据&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;setState&quot;&gt;&lt;a href=&quot;#setState&quot; class=&quot;headerlink&quot; title=&quot;setState&quot;&gt;&lt;/a&gt;setState&lt;/h1&gt;&lt;h2 id=&quot;更新数据&quot;&gt;&lt;a href=&quot;#更新数据&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>组件生命周期</title>
    <link href="http://example.com/2023/04/24/04-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2023/04/24/04-%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-04-24T11:14:22.833Z</published>
    <updated>2023-04-24T12:15:15.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li> 意义：组件的生命周期有助于理解组件的运行方式、完成更复杂的组件功能、分析组件错误原因等</li><li>组件的生命周期：组件从被创建到挂载到页面中运行，再到组件不用时卸载的过程</li><li> 钩子函数的作用：为开发人员在不同阶段操作组件提供了时机。</li><li> <strong>只有 类组件 才有生命周期。</strong></li></ul><h2 id="生命周期的整体说明"><a href="#生命周期的整体说明" class="headerlink" title="生命周期的整体说明"></a>生命周期的整体说明</h2><ul><li>每个阶段的执行时机</li><li>每个阶段钩子函数的执行顺序</li><li>每个阶段钩子函数的作用</li><li><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="lozad post-image"src="images/%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><h2 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h2><p>执行时机：组件创建时（页面加载时）</p><p>执行顺序：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%BB%84%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="lozad post-image"src="images/%E7%BB%84%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png"></p><table><thead><tr><th>钩子 函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>constructor</td><td>创建组件时，最先执行</td><td>1. 初始化state  2. 创建Ref等</td></tr><tr><td>render</td><td>每次组件渲染都会触发</td><td>渲染UI（<strong>注意： 不能调用setState()</strong> ）</td></tr><tr><td>componentDidMount</td><td>组件挂载（完成DOM渲染）后</td><td>1. 发送网络请求   2.DOM操作</td></tr></tbody></table><h2 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h2><ul><li>执行时机：1. setState() 2. forceUpdate() 3. 组件接收到新的props</li><li>说明：以上三者任意一种变化，组件就会重新渲染</li><li>执行顺序</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5.png" class="lozad post-image"src="images/%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5.png"></p><table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>render</td><td>每次组件渲染都会触发</td><td>渲染UI（与 挂载阶段 是同一个render）</td></tr><tr><td>componentDidUpdate</td><td>组件更新（完成DOM渲染）后</td><td>DOM操作，可以获取到更新后的DOM内容，不要调用setState</td></tr></tbody></table><h2 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h2><ul><li>执行时机：组件从页面中消失</li></ul><table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>componentWillUnmount</td><td>组件卸载（从页面中消失）</td><td>执行清理工作（比如：清理定时器等）</td></tr></tbody></table><h1 id="todomvc案例优化"><a href="#todomvc案例优化" class="headerlink" title="todomvc案例优化"></a>todomvc案例优化</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组件的生命周期&quot;&gt;&lt;a href=&quot;#组件的生命周期&quot; class=&quot;headerlink&quot; title=&quot;组件的生命周期&quot;&gt;&lt;/a&gt;组件的生命周期&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>组件通讯</title>
    <link href="http://example.com/2023/04/24/03-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/"/>
    <id>http://example.com/2023/04/24/03-%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF/</id>
    <published>2023-04-24T11:14:22.808Z</published>
    <updated>2023-04-24T12:15:11.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>组件通讯介绍以及为什么要有组件通讯</li><li>组件的props</li><li>组件通讯的三种方式 父传子  子传父  兄弟组件</li><li>Context组件通讯</li><li>props深入</li></ul><h1 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h1><p><strong>组件</strong>是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能<br>拆分成多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据<br>。为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通。这个过程就是<strong>组件通讯</strong>。</p><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><ul><li>组件是封闭的，要接收外部数据应该通过props来实现</li><li><strong>props的作用：接收传递给组件的数据</strong></li><li>传递数据：给组件标签添加属性</li><li>接收数据：函数组件通过参数props接收数据，类组件通过this.props接收数据</li></ul><h3 id="函数组件通讯"><a href="#函数组件通讯" class="headerlink" title="函数组件通讯"></a>函数组件通讯</h3><p>子组件</p><pre class="highlight"><span class="line"><span class="keyword">function</span> <span class="title function_">Hello</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>接收到数据：&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre><p>父组件</p><pre class="highlight"><span class="line">&lt;<span class="title class_">Hello</span> name=<span class="string">&quot;jack&quot;</span> age=&#123;<span class="number">19</span>&#125; /&gt;</span><br></pre><h3 id="类组件通讯"><a href="#类组件通讯" class="headerlink" title="类组件通讯"></a>类组件通讯</h3><p>子组件</p><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>接收到的数据：&#123;this.props.age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><p>父组件</p><pre class="highlight"><span class="line">&lt;<span class="title class_">Hello</span> name=<span class="string">&quot;jack&quot;</span> age=&#123;<span class="number">19</span>&#125; /&gt;</span><br></pre><h3 id="props的特点"><a href="#props的特点" class="headerlink" title="props的特点"></a>props的特点</h3><ul><li><p>可以给组件传递任意类型的数据</p></li><li><p>props是只读的，不允许修改props的数据</p></li><li><p>注意：在类组件中使用的时候，**需要把props传递给super()**，否则构造函数无法获取到props</p></li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="comment">// 推荐将props传递给父类构造函数</span></span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>接收到的数据：&#123;this.props.age&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><h2 id="组件通讯三种方式"><a href="#组件通讯三种方式" class="headerlink" title="组件通讯三种方式"></a>组件通讯三种方式</h2><ul><li>父传子</li><li>子传父</li><li>非父子</li></ul><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><ol><li>父组件提供要传递的state数据</li><li>给子组件标签添加属性，值为 state 中的数据</li><li>子组件中通过 props 接收父组件中传递的数据</li></ol><p>父组件提供数据并且传递给子组件</p><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123; <span class="attr">lastName</span>: <span class="string">&#x27;王&#x27;</span> &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                传递数据给子组件：<span class="tag">&lt;<span class="name">Child</span> <span class="attr">name</span>=<span class="string">&#123;this.state.lastName&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><p>子组件接收数据</p><pre class="highlight"><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>子组件接收到数据：&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre><h3 id="评论列表案例"><a href="#评论列表案例" class="headerlink" title="评论列表案例"></a>评论列表案例</h3><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>思路：利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数。</p><ol><li>父组件提供一个回调函数（用于接收数据）</li><li>将该函数作为属性的值，传递给子组件</li><li>子组件通过 props 调用回调函数</li><li>将子组件的数据作为参数传递给回调函数</li></ol><p>父组件提供函数并且传递给字符串</p><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    getChildMsg = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收到子组件数据&#x27;</span>, msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            子组件：<span class="tag">&lt;<span class="name">Child</span> <span class="attr">getMsg</span>=<span class="string">&#123;this.getChildMsg&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><p>子组件接收函数并且调用</p><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123; <span class="attr">childMsg</span>: <span class="string">&#x27;React&#x27;</span> &#125;</span><br><span class="line">    handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">getMsg</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">childMsg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我，给父组件传递数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre><p><strong>注意：回调函数中 this 指向问题！</strong></p><h3 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h3><ul><li>将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态</li><li>思想：<strong>状态提升</strong></li><li>公共父组件职责：<ul><li>提供共享状态 </li><li>提供操作共享状态的方法</li></ul></li><li>要通讯的子组件只需通过 props 接收状态或操作状态的方法</li></ul><p>状态提升前</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%8701.png" class="lozad post-image"src="images/%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%8701.png"></p><p>状态提升之后</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%8702.png" class="lozad post-image"src="images/%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%8702.png"></p><h2 id="组件通讯-context"><a href="#组件通讯-context" class="headerlink" title="组件通讯-context"></a>组件通讯-context</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>思考：App 组件要传递数据给 Child 组件，该如何处理？</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/context01.png" class="lozad post-image"src="images/context01.png"></p><p>处理方式：使用 props 一层层组件往下传递（繁琐）</p><p>更好的姿势：使用 Context</p><p> 作用：跨组件传递数据（比如：主题、语言等）</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/context02.png" class="lozad post-image"src="images/context02.png"></p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ul><li>调用 React. createContext() 创建 Provider（提供数据） 和 Consumer（消费数据） 两个组件。</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Consumer</span> &#125; = <span class="title class_">React</span>.<span class="title function_">createContext</span>()</span><br></pre><ul><li>使用 Provider 组件作为父节点。</li></ul><pre class="highlight"><span class="line">&lt;<span class="title class_">Provider</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Child1</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre><ul><li>设置 value 属性，表示要传递的数据。</li></ul><pre class="highlight"><span class="line">&lt;<span class="title class_">Provider</span> value=<span class="string">&quot;pink&quot;</span>&gt;</span><br></pre><ul><li>调用 Consumer 组件接收数据。</li></ul><pre class="highlight"><span class="line">&lt;<span class="title class_">Consumer</span>&gt;</span><br><span class="line">&#123;<span class="function"><span class="params">data</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>data参数表示接收到的数据 -- &#123;data&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">&lt;/<span class="title class_">Consumer</span>&gt;</span><br></pre><p>总结：</p><ol><li>如果两个组件是远方亲戚（比如，嵌套多层）可以使用Context实现组件通讯</li><li>Context提供了两个组件：Provider 和 Consumer</li><li>Provider组件：用来提供数据</li><li>Consumer组件：用来消费数据</li></ol><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><h1 id="props深入"><a href="#props深入" class="headerlink" title="props深入"></a>props深入</h1><h2 id="children属性"><a href="#children属性" class="headerlink" title="children属性"></a>children属性</h2><p>children属性：表示该组件的子节点，只要组件有子节点，props就有该属性</p><p>children 属性与普通的props一样，值可以是任意值（文本、React元素、组件，甚至是函数）</p><pre class="highlight"><span class="line"><span class="keyword">function</span> <span class="title function_">Hello</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      该组件的子节点：&#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Hello</span>&gt;我是子节点&lt;/<span class="title class_">Hello</span>&gt;</span><br><span class="line"></span><br></pre><h2 id="props校验"><a href="#props校验" class="headerlink" title="props校验"></a>props校验</h2><p>目的：校验接收的props的数据类型，增加组件的健壮性</p><p>对于组件来说，props是外来的，无法保证组件使用者传入什么格式的数据</p><p>如果传入的数据格式不对，可能会导致组件内部报错。<strong>组件的使用者不能很明确的知道错误的原因。</strong></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/props%E6%A0%A1%E9%AA%8C.png" class="lozad post-image"src="images/props%E6%A0%A1%E9%AA%8C.png"></p><p>props校验允许在创建组件的时候，就约定props的格式、类型等</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/props%E6%A0%A1%E9%AA%8C02.png" class="lozad post-image"src="images/props%E6%A0%A1%E9%AA%8C02.png"></p><p>作用：规定接收的props的类型必须为数组，如果不是数组就会报错，增加组件的健壮性。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/props%E6%A0%A1%E9%AA%8C03.png" class="lozad post-image"src="images/props%E6%A0%A1%E9%AA%8C03.png"></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol start="2"><li>导入 prop-types 包</li><li>使用组件名.propTypes = {} 来给组件的props添加校验规则</li><li>校验规则通过 PropTypes 对象来指定</li></ol><pre class="highlight"><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi, &#123;props.colors&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">App</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="comment">// 约定colors属性为array类型</span></span><br><span class="line">    <span class="comment">// 如果类型不对，则报出明确错误，便于分析错误原因</span></span><br><span class="line">    <span class="attr">colors</span>: <span class="title class_">PropTypes</span>.<span class="property">array</span></span><br><span class="line">&#125;</span><br></pre><h3 id="约束规则"><a href="#约束规则" class="headerlink" title="约束规则"></a>约束规则</h3><ol><li>常见类型：array、bool、func、number、object、string</li><li>React元素类型：element</li><li>必填项：isRequired</li><li>特定结构的对象：shape({})</li></ol><pre class="highlight"><span class="line"><span class="comment">// 常见类型</span></span><br><span class="line"><span class="attr">optionalFunc</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>,</span><br><span class="line"><span class="comment">// 必选</span></span><br><span class="line"><span class="attr">requiredFunc</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line"><span class="comment">// 特定结构的对象</span></span><br><span class="line"><span class="attr">optionalObjectWithShape</span>: <span class="title class_">PropTypes</span>.<span class="title function_">shape</span>(&#123;</span><br><span class="line"><span class="attr">color</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line"><span class="attr">fontSize</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span></span><br><span class="line">&#125;)</span><br></pre><h2 id="props默认值"><a href="#props默认值" class="headerlink" title="props默认值"></a>props默认值</h2><p>场景：分页组件  每页显示条数<br>作用：给 props 设置默认值，在未传入 props 时生效</p><pre class="highlight"><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            此处展示props的默认值：&#123;props.pageSize&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line"><span class="title class_">App</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line"><span class="attr">pageSize</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不传入pageSize属性</span></span><br><span class="line">&lt;<span class="title class_">App</span> /&gt;</span><br></pre><h2 id="类的静态属性static"><a href="#类的静态属性static" class="headerlink" title="类的静态属性static"></a>类的静态属性static</h2><ul><li><p>实例成员: 通过实例调用的属性或者方法，，，叫做实例成员（属性或者方法）</p></li><li><p>静态成员：通过类或者构造函数本身才能访问的属性或者方法</p></li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   name = <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">   <span class="keyword">static</span> age = <span class="number">18</span></span><br><span class="line">   <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;哈哈&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="title function_">goodBye</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;byebye&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>)</span><br><span class="line">p.<span class="title function_">sayHi</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">age</span>)</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">goodBye</span>()</span><br></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;组件通讯介绍以及为什么要有组件通讯&lt;/li&gt;
&lt;li&gt;组件的props&lt;/li&gt;
&lt;li&gt;组件通讯的三种方式 父</summary>
      
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>组件基本介绍</title>
    <link href="http://example.com/2023/04/24/02-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/04/24/02-%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-24T11:14:22.780Z</published>
    <updated>2023-04-24T12:15:07.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>能够使用函数创建组件-函数组件</li><li>能够掌握class语法 extends继承</li><li>能够使用class创建组件-类组件</li><li>能够给React元素绑定事件</li><li>能够使用state与setState</li><li>能够处理事件中this的指向问题</li><li>能够使用受控组件方式处理表单</li></ul><h1 id="组件基本介绍"><a href="#组件基本介绍" class="headerlink" title="组件基本介绍"></a>组件基本介绍</h1><ul><li>组件是React中最基本的内容，使用React就是在使用组件</li><li>组件表示页面中的部分功能</li><li>多个组件可以实现完整的页面功能</li><li>组件特点：可复用，独立，可组合 </li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%BB%84%E4%BB%B6.png" class="lozad post-image"src="images/%E7%BB%84%E4%BB%B6.png"></p><h1 id="React创建组件的两种方式"><a href="#React创建组件的两种方式" class="headerlink" title="React创建组件的两种方式"></a>React创建组件的两种方式</h1><h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><blockquote><p>函数组件：使用JS的函数或者箭头函数创建的组件</p></blockquote><ul><li>为了区分普通标签，函数组件的名称必须<code>大写字母开头</code></li><li>函数组件<code>必须有返回值</code>，表示该组件的结构</li><li>如果返回值为null,表示不渲染任何内容</li></ul><p>使用函数创建组件</p><pre class="highlight"><span class="line"><span class="keyword">function</span> <span class="title function_">Hello</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是我的函数组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre><p>使用箭头函数创建组件</p><pre class="highlight"><span class="line"><span class="keyword">const</span> <span class="title function_">Hello</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个函数组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre><p>使用组件</p><pre class="highlight"><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre><h2 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h2><h3 id="class-基本语法"><a href="#class-基本语法" class="headerlink" title="class 基本语法"></a>class 基本语法</h3><ul><li>在 ES6 之前通过构造函数创建对象</li><li>在 ES6 中新增了一个关键字 class, 类 和构造函数类似，用于创建对象<ul><li>类与对象的区别</li><li>类：指的是一类的事物，是个概念，比如车 手机 水杯等</li><li>对象：一个具体的事物，有具体的特征和行为，比如一个手机，我的手机等， 类可以创建出来对象。</li></ul></li><li>类创建对象的基本语法<ul><li>基本语法<code>class 类名&#123;&#125;</code></li><li>构造函数<code>constructor</code>的用法，创建对象</li><li>在类中提供方法，直接提供即可</li><li>在类中不需要使用,分隔</li></ul></li></ul><h3 id="extends-实现继承"><a href="#extends-实现继承" class="headerlink" title="extends 实现继承"></a>extends 实现继承</h3><ul><li>extends 基本使用</li><li>类可以使用它继承的类中所有的成员（属性和方法）</li><li>类中可以提供自己的属性和方法</li><li>注意：如果想要给类中新增属性，必须先调用 super 方法</li></ul><h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><blockquote><p>类组件：使用ES6的class语法创建组件</p></blockquote><p>约定1：类组件的名称必须是大写字母开头</p><p>约定2：类组件应该继承<code>React.Component</code>父类，从而可以使用父类中提供的方法或者属性</p><p>约定3：类组件必须提供<code>render</code>方法</p><p>约定4：render方法<code>必须有返回值</code>,表示该组件的结构</p><p>定义组件</p><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个类组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre><p>使用组件</p><pre class="highlight"><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre><h2 id="将组件提取到单独的js文件中"><a href="#将组件提取到单独的js文件中" class="headerlink" title="将组件提取到单独的js文件中"></a>将组件提取到单独的js文件中</h2><p>思考：项目中的组件多了之后，该如何组织这些组件呢？</p><ul><li>选择一：将所有组件放在同一个JS文件中</li><li>选择二：将每个组件放到单独的JS文件中</li><li>组件作为一个独立的个体，一般都会放到一个单独的 JS 文件中</li></ul><p>实现方式</p><ol><li><p>创建Hello.js</p></li><li><p>创建组件（函数 或 类）</p></li><li><p>在 Hello.js 中导出该组件</p></li><li><p>在 index.js 中导入 Hello 组件</p></li><li><p>渲染组件，</p></li></ol><h2 id="有状态组件和无状态组件"><a href="#有状态组件和无状态组件" class="headerlink" title="有状态组件和无状态组件"></a>有状态组件和无状态组件</h2><ul><li>函数组件又叫做<strong>无状态组件</strong>   函数组件是不能自己提供数据【前提：基于hooks之前说的】</li><li>类组件又叫做<strong>有状态组件</strong> 类组件可以自己提供数据，，，，组件内部的状态（数据如果发生了改变，内容会自动的更新）数据驱动视图</li><li>状态（state）即组件的私有数据，当组件的状态发生了改变，页面结构也就发生了改变。</li><li>函数组件是没有状态的，只负责页面的展示（静态，不会发生变化）性能比较高</li><li>类组件有自己的状态，负责<strong>更新UI</strong>，只要类组件的数据发生了改变，UI就会发生更新。</li><li>在复杂的项目中，一般都是由函数组件和类组件共同配合来完成的。【增加了使用者的负担，所以后来有了hooks】</li></ul><p>比如计数器案例，点击按钮让数值+1， 0和1就是不同时刻的状态，当状态从0变成1之后，UI也要跟着发生变化。React想要实现这种功能，就需要使用有状态组件来完成。</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/state%E7%BB%84%E4%BB%B6.png" class="lozad post-image"src="images/state%E7%BB%84%E4%BB%B6.png"></p><h2 id="类组件的状态"><a href="#类组件的状态" class="headerlink" title="类组件的状态"></a>类组件的状态</h2><ul><li>状态<code>state</code>即数据，是组件内部的<code>私有数据</code>,只有在组件内部可以使用</li><li><code>state的值是一个对象</code>,表示一个组件中可以有多个数据</li><li>state的基本使用</li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="comment">// 组件通过state提供数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>state中的数据--&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><ul><li>简洁的语法</li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>state中的数据--&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><h2 id="react插件的安装（没网）"><a href="#react插件的安装（没网）" class="headerlink" title="react插件的安装（没网）"></a>react插件的安装（没网）</h2><p>安装谷歌插件<code>react-devtools</code></p><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><p>React注册事件与DOM的事件语法非常像</p><p>语法<code>on+事件名=｛事件处理程序｝</code> 比如<code>onClick=&#123;this.handleClick&#125;</code></p><p>注意：<strong>React事件采用驼峰命名法</strong>，比如<code>onMouseEnter</code>, <code>onClick</code></p><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击事件触发了&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ul><li>可以通过事件处理程序的参数获取到事件对象</li></ul><pre class="highlight"><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件对象&#x27;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line">&lt;a onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;&gt;点我，不会跳转页面&lt;/a&gt;</span><br></pre><h2 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h2><blockquote><p>事件处理程序中的this指向的是undefined</p><p>render方法中的this指向的而是当前react组件。<strong>只有事件处理程序中的this有问题</strong></p></blockquote><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><h2 id="this指向问题解决方案"><a href="#this指向问题解决方案" class="headerlink" title="this指向问题解决方案"></a>this指向问题解决方案</h2><pre class="highlight"><span class="line">方案<span class="number">1</span>：箭头函数</span><br><span class="line">方案<span class="number">2</span>：bind修改<span class="variable language_">this</span>指向</span><br><span class="line">方案<span class="number">3</span>：类实例方法</span><br></pre><ul><li>在render中使用箭头函数</li></ul><p>箭头函数的特点：自身没有this，访问的是外部的this</p><p>方式1：</p><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123; console.log(this.state.msg) &#125;&gt;点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><p>缺点：会把大量的js处理逻辑放到JSX中，将来不容易维护</p><p>方式2</p><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;this.handleClick()&#125;&#125;&gt;点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><p>缺点：把大量的js逻辑写在了JSX结构中，不好维护</p><ul><li>解决方案2：使用bind</li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><p>或者</p><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><ul><li>解决方案3：class实例方法</li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><p><strong>注意：这个语法是试验性的语法，但是有babel的转义，所以没有任何问题</strong></p><h1 id="setState修改状态"><a href="#setState修改状态" class="headerlink" title="setState修改状态"></a>setState修改状态</h1><ul><li><p>组件中的状态是可变的</p></li><li><p>语法<code>this.setState(&#123;要修改的数据&#125;)</code></p></li><li><p>注意：不要直接修改state中的值，必须通过<code>this.setState()</code>方法进行修改</p></li><li><p><code>setState</code>的作用</p><ul><li>修改state</li><li>更新UI</li></ul></li><li><p>思想：数据驱动视图</p></li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>次数: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><ul><li>react中核心理念：<strong>状态不可变</strong><ul><li>不要直接修改react中state的值，而是提供新的值</li><li>直接修改react中state的值，组件并不会更新</li></ul></li></ul><pre class="highlight"><span class="line">state = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">list</span>: []</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接修改值的操作</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>++</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>.<span class="title function_">push</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的值的操作</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="attr">list</span>: [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre><h1 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h1><blockquote><p>我们在开发过程中，经常需要操作表单元素，比如获取表单的值或者是设置表单的值。</p></blockquote><p>react中处理表单元素有两种方式：</p><ul><li>受控组件</li><li>非受控组件（DOM操作）</li></ul><h2 id="受控组件基本概念"><a href="#受控组件基本概念" class="headerlink" title="受控组件基本概念"></a>受控组件基本概念</h2><ul><li><p>HTML中表单元素是可输入的，即表单用户并维护着自己的可变状态（value）。</p></li><li><p>但是在react中，可变状态通常是保存在state中的，并且要求状态只能通过<code>setState</code>进行修改。</p></li><li><p>React中将state中的数据与表单元素的value值绑定到了一起，<code>由state的值来控制表单元素的值</code></p></li><li><p>受控组件：<strong>value值受到了react控制的表单元素</strong> </p></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6.png" class="lozad post-image"src="images/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6.png"></p><h2 id="受控组件使用步骤"><a href="#受控组件使用步骤" class="headerlink" title="受控组件使用步骤"></a>受控组件使用步骤</h2><ol><li>在state中添加一个状态，作为表单元素的value值（控制表单元素的值）</li><li>给表单元素添加change事件，设置state的值为表单元素的值（控制值的变化）</li></ol><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">msg</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.msg&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><h2 id="常见的受控组件"><a href="#常见的受控组件" class="headerlink" title="常见的受控组件"></a>常见的受控组件</h2><ul><li>文本框、文本域、下拉框（操作value属性）</li><li>复选框（操作checked属性）</li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">usernmae</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">isSingle</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  handleName = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleDesc = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">desc</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleCity = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">city</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  handleSingle = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">isSingle</span>: e.<span class="property">target</span>.<span class="property">checked</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.username&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleName&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        描述：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">value</span>=<span class="string">&#123;this.state.desc&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleDesc&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        城市：<span class="tag">&lt;<span class="name">select</span> <span class="attr">value</span>=<span class="string">&#123;this.state.city&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleCity&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        是否单身：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&#123;this.state.isSingle&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleSingle&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><h2 id="多表单元素的优化"><a href="#多表单元素的优化" class="headerlink" title="多表单元素的优化"></a>多表单元素的优化</h2><p>问题：每个表单元素都需要一个单独的事件处理程序，处理太繁琐</p><p>优化：使用一个事件处理程序处理多个表单元素</p><p>步骤</p><ul><li>给表单元素添加name属性，名称与state属性名相同</li><li>根据表单元素类型获取对应的值</li><li>在事件处理程序中通过<code>[name]</code>修改对应的state</li></ul><pre class="highlight"><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">isSingle</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  handleChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;name, type, value, checked&#125; = e.<span class="property">target</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name, type, value, checked)</span><br><span class="line">    value = type === <span class="string">&#x27;checkbox&#x27;</span> ? checked : value</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name, value)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.username&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        描述：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;desc&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.desc&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        城市：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.city&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        是否单身：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;isSingle&quot;</span> <span class="attr">checked</span>=<span class="string">&#123;this.state.isSingle&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><h2 id="非受控组件-ref"><a href="#非受控组件-ref" class="headerlink" title="非受控组件-ref"></a>非受控组件-ref</h2><blockquote><p>非受控组件借助于ref，使用原生DOM的方式来获取表单元素的值</p></blockquote><p>使用步骤</p><ul><li>调用<code>React.createRef()</code>方法创建一个ref </li></ul><pre class="highlight"><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">txtRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">&#125;</span><br><span class="line">txtRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br></pre><ul><li>将创建好的ref对象添加到文本框中</li></ul><pre class="highlight"><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> ref=&#123;<span class="variable language_">this</span>.<span class="property">txtRef</span>&#125;/&gt;</span><br></pre><ul><li>通过ref对象获取文本框的值</li></ul><pre class="highlight"><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">txtRef</span>.<span class="property">current</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre><p>非受控组件用的不多，推荐使用受控组件</p><h1 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h1><p>评论列表案例</p><h2 id="列表展示功能"><a href="#列表展示功能" class="headerlink" title="列表展示功能"></a>列表展示功能</h2><p>渲染评论列表（列表渲染）</p><ul><li>在state中初始化评论列表数据</li><li>使用数组的map方法遍历列表数据</li><li>给每个li添加key属性</li></ul><h2 id="发表评论功能"><a href="#发表评论功能" class="headerlink" title="发表评论功能"></a>发表评论功能</h2><p>获取评论信息，评论人和评论内容（受控组件）</p><ul><li>使用受控组件的方式获取评论数据</li></ul><p>发表评论，更新评论列表（更新状态）</p><ul><li>给comments增加一条数据</li></ul><p>边界处理</p><ul><li>清空内容</li><li>判断非空</li></ul><h2 id="清空评论功能"><a href="#清空评论功能" class="headerlink" title="清空评论功能"></a>清空评论功能</h2><ul><li><p>给清空评论按钮注册事件</p></li><li><p>清空评论列表</p></li><li><p>没有更多评论的处理</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;能够使用函数创建组件-函数组件&lt;/li&gt;
&lt;li&gt;能够掌握class语法 extends继承&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>React概述</title>
    <link href="http://example.com/2023/04/24/01-React%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/04/24/01-React%20%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-24T11:14:22.757Z</published>
    <updated>2023-04-24T12:15:05.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h1><p><img src="images/image-20210816173421106.png" alt="image-20210816173421106" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210816173421106.png" class="lozad post-image"></p><h1 id="React-概述"><a href="#React-概述" class="headerlink" title="React 概述"></a>React 概述</h1><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>能够说出react是什么</li><li>能够说出react的特点</li><li>能够掌握react的基本用法</li><li>能够使用react脚手架</li></ul><h2 id="React-介绍"><a href="#React-介绍" class="headerlink" title="React 介绍"></a>React 介绍</h2><p><img src="./images/react_logo.jpeg" alt="React Logo" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="./images/react_logo.jpeg" class="lozad post-image"></p><blockquote><p>react是一个用于构建用户<strong>界面</strong>的 JavaScript 库</p><p>react官网(<a href="https://reactjs.org/">https://reactjs.org/</a>)</p><p>react中文网(<a href="https://zh-hans.reactjs.org/">https://zh-hans.reactjs.org/</a>)</p></blockquote><ul><li>React 是一个用于构建用户界面（UI，对咱们前端来说，简单理解为：HTML 页面）的 JavaScript 库</li><li>如果从mvc的角度来看，React仅仅是视图层（V）的解决方案。也就是只负责视图的渲染，并非提供了完整了M和C的功能</li><li>react/react-dom/react-router/redux: 框架</li><li>React 起源于 Facebook 内部项目（News Feed，2011），后又用来架设 Instagram 的网站（2012），并于 2013 年 5 月开源<a href="https://baike.baidu.com/item/react/18077599?fr=aladdin">react介绍</a></li><li>React 是最流行的前端开发框架之一，其他：Vue、Angular 等等<a href="https://www.npmtrends.com/">框架对比</a></li></ul><h2 id="react特点"><a href="#react特点" class="headerlink" title="react特点"></a>react特点</h2><h3 id="声明式UI"><a href="#声明式UI" class="headerlink" title="声明式UI"></a>声明式UI</h3><p>你只需要描述UI（HTML）看起来是什么样的，就跟写HTML一样</p><pre class="highlight"><span class="line"><span class="keyword">const</span> jsx = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React! 动态数据变化:&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre><p>声明式对应的是命令式，声明式关注的是what，命令式关注的是how</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><ul><li>组件是react中<strong>最重要</strong>的内容</li><li>组件用于表示页面中的部分内容</li><li>组合、复用多个组件，就可以实现完整的页面功能</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%BB%84%E4%BB%B6-1629115179921.png" class="lozad post-image"src="images/%E7%BB%84%E4%BB%B6-1629115179921.png"></p><h3 id="学习一次，随处使用"><a href="#学习一次，随处使用" class="headerlink" title="学习一次，随处使用"></a>学习一次，随处使用</h3><ul><li>使用react/rect-dom可以开发Web应用</li><li>使用react/react-native可以开发移动端原生应用（react-native）  RN   安卓 和 ios应用    flutter</li><li>使用react可以开发VR（虚拟现实）应用（react360）</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/react-use-1629115179922.png" class="lozad post-image"src="images/react-use-1629115179922.png"></p><p>从你的角度看 React 特点：</p><ul><li>工资高、大厂必备（阿里在用）</li><li>工资高、大厂必备（字节跳动在用）</li><li>工资高、大厂必备（百度、腾讯、京东、蚂蚁金服、拼多多、美团、外企、银行等都在用）</li></ul><h2 id="React-脚手架（CLI）"><a href="#React-脚手架（CLI）" class="headerlink" title="React 脚手架（CLI）"></a>React 脚手架（CLI）</h2><ul><li>React 脚手架的介绍</li><li>使用 React 脚手架创建项目</li><li>项目目录结构调整</li></ul><h3 id="React-脚手架的介绍"><a href="#React-脚手架的介绍" class="headerlink" title="React 脚手架的介绍"></a>React 脚手架的介绍</h3><ul><li>脚手架：为了保证各施工过程顺利进行而搭设的工作平台</li><li>对于前端项目开发来说，脚手架是为了保证前端项目开发过程顺利进行而搭设的开发平台</li><li>脚手架的意义：<ul><li>现代的前端开发日趋成熟，需要依赖于各种工具，比如，webpack、babel、eslint、sass/less/postcss等</li><li>工具配置繁琐、重复，各项目之间的配置大同小异</li><li>开发阶段、项目发布，配置不同<ul><li>项目开始前，帮你搭好架子，省去繁琐的 webpack 配置</li><li>项目开发时，热更新、格式化代码、git 提交时自动校验代码格式等</li><li>项目发布时，一键自动打包，包括：代码压缩、优化、按需加载等</li></ul></li></ul></li></ul><h3 id="使用-React-脚手架创建项目"><a href="#使用-React-脚手架创建项目" class="headerlink" title="使用 React 脚手架创建项目"></a>使用 React 脚手架创建项目</h3><ul><li>命令：<code>npx create-react-app react-basic</code><ul><li>npx create-react-app 是固定命令，<code>create-react-app</code> 是 React 脚手架的名称</li><li>react-basic 表示项目名称，可以修改</li></ul></li><li>启动项目：<code>yarn start</code> or <code>npm start</code></li><li><code>npx</code> 是 npm v5.2 版本新添加的命令，用来简化 npm 中工具包的使用<ul><li>原始：1 全局安装 <code>npm i -g create-react-app</code> 2 在通过脚手架的命令来创建 React 项目</li><li>现在：npx 调用最新的 create-react-app 直接创建 React 项目</li></ul></li></ul><h3 id="项目目录结构说明和调整"><a href="#项目目录结构说明和调整" class="headerlink" title="项目目录结构说明和调整"></a>项目目录结构说明和调整</h3><ul><li>说明：<ul><li><code>src</code> 目录是我们写代码进行项目开发的目录</li><li>查看 <code>package.json</code> 两个核心库：<code>react</code>、<code>react-dom</code>（脚手架已经帮我们安装好，我们直接用即可）</li></ul></li><li>调整：<ol><li>删除 src 目录下的所有文件</li><li>创建 index.js 文件作为项目的入口文件，在这个文件中写 React 代码即可</li></ol></li></ul><h2 id="React-的基本使用"><a href="#React-的基本使用" class="headerlink" title="React 的基本使用"></a>React 的基本使用</h2><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ul><li>使用步骤</li></ul><pre class="highlight"><span class="line">- 导入react和react-dom   </span><br><span class="line">- 创建react元素(虚拟DOM)</span><br><span class="line">- 渲染react元素到页面中</span><br></pre><ul><li>导入react和react-dom</li></ul><pre class="highlight"><span class="line"><span class="comment">// 导入react和react-dom</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br></pre><ul><li>创建react元素</li></ul><pre class="highlight"><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line"><span class="keyword">const</span> title = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello react&#x27;</span>)</span><br></pre><ul><li>渲染react元素到页面</li></ul><pre class="highlight"><span class="line"><span class="comment">// 渲染react元素</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(title, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li>使用react，生成以下结构</li></ol><pre class="highlight"><span class="line">&lt;div id=<span class="string">&quot;box&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;demo&quot;</span>&gt;这是一个react案例&lt;/div&gt;</span><br></pre><ol start="2"><li>生成结构2</li></ol><pre class="highlight"><span class="line">&lt;ul <span class="keyword">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>能够说出react是什么<ul><li>是用于构建用户界面的javascript库</li></ul></li><li>能够说出react的特点<ul><li>声明式ui</li><li>组件化</li><li>一处学习，多次使用  react-dom  react-native</li></ul></li><li>能够掌握react的基本用法</li><li>能够使用react脚手架<ul><li><code>yarn global add create-react-app</code></li></ul></li></ul><h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><h2 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h2><ul><li>能够知道什么是jsx</li><li>能够使用jsx创建react元素</li><li>能够在jsx中使用javascript表达式 <code>&#123;&#125;</code></li><li>能够使用jsx的条件渲染和列表渲染</li><li>能够给jsx添加样式</li></ul><h2 id="JSX的基本使用"><a href="#JSX的基本使用" class="headerlink" title="JSX的基本使用"></a>JSX的基本使用</h2><h3 id="createElement的问题"><a href="#createElement的问题" class="headerlink" title="createElement的问题"></a>createElement的问题</h3><ul><li>繁琐不简洁</li><li>不直观，无法一眼看出所描述的结构</li><li>不优雅，开发体验不好</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="./images/jsx%E7%9A%84%E4%BC%98%E7%82%B9.png" class="lozad post-image"src="./images/jsx%E7%9A%84%E4%BC%98%E7%82%B9.png"></p><h3 id="JSX简介"><a href="#JSX简介" class="headerlink" title="JSX简介"></a>JSX简介</h3><p><code>JSX</code>是 <code>JavaScript XML</code>的简写，表示了在Javascript代码中写XML(HTML)格式的代码</p><p>优势：声明式语法更加直观，与HTML结构相同，降低学习成本，提高开发效率。</p><p> <strong>JSX是react的核心内容</strong></p><p>注意：<em>JSX 不是标准的 JS 语法，是 JS 的语法扩展。脚手架中内置的 <a href="@babel/plugin-transform-react-jsx">@babel/plugin-transform-react-jsx</a> 包，用来解析该语法。</em></p><p>![JSX 声明式vs命令式](images/JSX 声明式vs命令式-1629116328806.png)</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><pre class="highlight"><span class="line">- 导入react和reactDOM包</span><br><span class="line">- 使用jsx语法创建react元素</span><br><span class="line">- 把react元素渲染到页面中</span><br></pre><ul><li>导入react和reactDOM</li></ul><pre class="highlight"><span class="line"><span class="comment">// 导入react和react-dom</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br></pre><ul><li>创建react元素</li></ul><pre class="highlight"><span class="line"><span class="comment">// 创建元素</span></span><br><span class="line"><span class="keyword">const</span> title = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">title</span>=<span class="string">&quot;哈哈&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre><ul><li>渲染元素</li></ul><pre class="highlight"><span class="line"><span class="comment">// 渲染元素</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(title, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre><h3 id="JSX注意点"><a href="#JSX注意点" class="headerlink" title="JSX注意点"></a>JSX注意点</h3><ul><li><p>只有在脚手架中才能使用jsx语法</p><ul><li>因为JSX需要经过babel的编译处理，才能在浏览器中使用。脚手架中已经默认有了这个配置。</li></ul></li><li><p>JSX必须要有一个根节点， <code>&lt;&gt;&lt;/&gt;</code>  <code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code></p></li><li><p>没有子节点的元素可以使用 <code>/&gt;</code>结束</p></li><li><p>JSX中语法更接近与JavaScript</p><ul><li><code>class</code> =====&gt; <code>className</code></li><li><code>for</code>========&gt;  <code>htmlFor</code></li></ul></li><li><p>JSX可以换行，如果JSX有多行，推荐使用 <code>()</code>包裹JSX，防止自动插入分号的bug</p></li></ul><h2 id="使用prettier插件格式化react代码"><a href="#使用prettier插件格式化react代码" class="headerlink" title="使用prettier插件格式化react代码"></a>使用prettier插件格式化react代码</h2><ul><li>安装插件</li></ul><p><img src="images/image-20200907165515629-1629115818044.png" alt="image-20200907165515629" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20200907165515629-1629115818044.png" class="lozad post-image"></p><ul><li>添加prettier的配置</li></ul><pre class="highlight"><span class="line"><span class="comment">// 保存到额时候用使用prettier进行格式化</span></span><br><span class="line"><span class="string">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 不要有分号</span></span><br><span class="line"><span class="string">&quot;prettier.semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 使用单引号</span></span><br><span class="line"><span class="string">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// 默认使用prittier作为格式化工具</span></span><br><span class="line"><span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span>,</span><br></pre><h2 id="JSX中嵌入JavaScript表达式"><a href="#JSX中嵌入JavaScript表达式" class="headerlink" title="JSX中嵌入JavaScript表达式"></a>JSX中嵌入JavaScript表达式</h2><blockquote><p>在jsx中可以在 <code>&#123;&#125;</code>来使用js表达式</p></blockquote><ul><li>基本使用</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;zs&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> title = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    姓名：&#123;name&#125;, 年龄：&#123;age&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br></pre><ul><li>可以访问对象的属性</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">    <span class="attr">brand</span>: <span class="string">&#x27;玛莎拉蒂&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> title = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    汽车：&#123;car.brand&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br></pre><ul><li>可以访问数组的下标</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> friends = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> title = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    汽车：&#123;friends[1]&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br></pre><ul><li>可以使用三元运算符</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> gender = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> title = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    性别：&#123;age &gt;= 18? &#x27;是&#x27;:&#x27;否&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">)</span><br></pre><ul><li>可以调用方法</li></ul><pre class="highlight"><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> title = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>姓名：&#123;sayHi()&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre><ul><li>JSX本身</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> span = <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> title = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>盒子&#123;span&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre><ul><li>JSX中的注释</li></ul><pre class="highlight"><span class="line">&#123;<span class="comment">/* 这是jsx中的注释 */</span>&#125;   推荐快键键 ctrl + /</span><br></pre><ul><li>不要出现语句，比如 <code>if</code> <code>for</code></li></ul><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><blockquote><p>在react中，一切都是javascript，所以条件渲染完全是通过js来控制的</p></blockquote><ul><li>通过判断 <code>if/else</code>控制</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> isLoding = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loadData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (isLoding) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>数据加载中.....<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>数据加载完成，此处显示加载后的数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> title = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>条件渲染：&#123;loadData()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre><ul><li>通过三元运算符控制</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> isLoding = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loadData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> isLoding ? (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>数据加载中.....<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  ) : (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>数据加载完成，此处显示加载后的数据<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre><ul><li>逻辑运算符</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> isLoding = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">loadData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> isLoding &amp;&amp; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>加载中...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> title = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>条件渲染：&#123;loadData()&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre><h2 id="vscode配置自动补全"><a href="#vscode配置自动补全" class="headerlink" title="vscode配置自动补全"></a>vscode配置自动补全</h2><pre class="highlight"><span class="line"><span class="comment">// 当按tab键的时候，会自动提示</span></span><br><span class="line"><span class="string">&quot;emmet.triggerExpansionOnTab&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">&quot;emmet.showAbbreviationSuggestions&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="comment">// jsx的提示</span></span><br><span class="line"><span class="string">&quot;emmet.includeLanguages&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;javascript&quot;</span>: <span class="string">&quot;javascriptreact&quot;</span></span><br><span class="line">&#125;</span><br></pre><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><blockquote><p>我们经常需要遍历一个数组来重复渲染一段结构</p><p>在react中，通过map方法进行列表的渲染</p></blockquote><ul><li>列表的渲染</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> songs = [<span class="string">&#x27;温柔&#x27;</span>, <span class="string">&#x27;倔强&#x27;</span>, <span class="string">&#x27;私奔到月球&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = songs.<span class="title function_">map</span>(<span class="function"><span class="params">song</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;song&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dv = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;list&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre><ul><li>直接在JSX中渲染</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> songs = [<span class="string">&#x27;温柔&#x27;</span>, <span class="string">&#x27;倔强&#x27;</span>, <span class="string">&#x27;私奔到月球&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dv = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;songs.map(song =&gt; <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;song&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre><ul><li>key属性的使用</li></ul><pre class="highlight"><span class="line"><span class="keyword">const</span> dv = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;songs.map(song =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;song&#125;</span>&gt;</span>&#123;song&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre><p><strong>注意：列表渲染时应该给重复渲染的元素添加key属性，key属性的值要保证唯一</strong></p><p><strong>注意：key值避免使用index下标，因为下标会发生改变</strong></p><h2 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h2><h3 id="行内样式-style"><a href="#行内样式-style" class="headerlink" title="行内样式-style"></a>行内样式-style</h3><pre class="highlight"><span class="line"><span class="keyword">const</span> dv = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">red</span>&#x27;, <span class="attr">backgroundColor:</span> &#x27;<span class="attr">pink</span>&#x27; &#125;&#125;&gt;</span>style样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre><h3 id="类名-className"><a href="#类名-className" class="headerlink" title="类名-className"></a>类名-className</h3><pre class="highlight"><span class="line"><span class="comment">// 导入样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./base.css&#x27;</span></span><br><span class="line"><span class="keyword">const</span> dv = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>style样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre><p>base.css样式文件</p><pre class="highlight"><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><pre class="highlight"><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;刘德华&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;给我一杯忘情水&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;五月天&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;不打扰，是我的温柔&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;毛不易&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;像我这样优秀的人&quot;</span> &#125;</span><br><span class="line">];</span><br></pre><p><img src="images/image-20210816202854520.png" alt="image-20210816202854520" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210816202854520.png" class="lozad post-image"></p><p><img src="images/image-20210816203947396.png" alt="image-20210816203947396" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/image-20210816203947396.png" class="lozad post-image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>JSX是React的核心内容</li><li>JSX表示在JS代码中书写HTML结构，是React声明式的体现</li><li>使用JSX配合嵌入的JS表达式，条件渲染，列表渲染，可以渲染任意的UI结构</li><li>结果使用className和style的方式给JSX添加样式</li><li>React完全利用JS的语言自身的能力来编写UI，而不是造轮子增强HTML的功能。（对比VUE）<br>tags:</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;课程安排&quot;&gt;&lt;a href=&quot;#课程安排&quot; class=&quot;headerlink&quot; title=&quot;课程安排&quot;&gt;&lt;/a&gt;课程安排&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;images/image-20210816173421106.png&quot; alt=&quot;image-20210</summary>
      
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>React原理揭秘</title>
    <link href="http://example.com/2023/04/24/react%E5%9F%BA%E7%A1%80Day04-React%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98&amp;React%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/04/24/react%E5%9F%BA%E7%A1%80Day04-React%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98&amp;React%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-24T09:02:12.621Z</published>
    <updated>2023-04-24T11:42:47.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React原理揭秘"><a href="#React原理揭秘" class="headerlink" title="React原理揭秘"></a>React原理揭秘</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>能够说出React组件的更新机制</li><li>能够对组件进行性能优化</li><li>能够说出虚拟DOM和DIff算法</li></ul><h2 id="组件更新机制"><a href="#组件更新机制" class="headerlink" title="组件更新机制"></a>组件更新机制</h2><ul><li><p>setState() 的两个作用</p><ul><li>修改state</li><li>更新组件</li></ul></li><li><p>过程：父组件重新渲染时，也会重新渲染子组件，但只会渲染当前组件子树（当前组件以其所有子组件）</p></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0.png" class="lozad post-image"src="images/%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0.png"></p><h2 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h2><h3 id="减轻state"><a href="#减轻state" class="headerlink" title="减轻state"></a>减轻state</h3><ul><li>减轻state：只存储跟组件渲染相关的数据（比如：count/ 列表数据 /loading等）</li><li>注意：不用做渲染的数据不要放在state中</li><li>对于这种需要在多个方法中用到的数据，应该放到this中</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%87%8F%E8%BD%BBstate.png" class="lozad post-image"src="images/%E5%87%8F%E8%BD%BBstate.png"></p><h3 id="避免不必要的重新渲染"><a href="#避免不必要的重新渲染" class="headerlink" title="避免不必要的重新渲染"></a>避免不必要的重新渲染</h3><ul><li>组件更新机制：父组件更新会引起子组件也被更新，这种思路很清晰</li><li>问题：子组件没有任何变化时也会重新渲染</li><li>如果避免不必要的重新渲染？</li><li>解决方式：使用钩子函数 shouldComponentUpdate(nextProps, nextState)<ul><li>在这个函数中，nextProps和nextState是最新的状态以及属性</li></ul></li><li>作用：这个函数有返回值，如果返回true，代表需要重新渲染，如果返回false，代表不需要重新渲染</li><li>触发时机：更新阶段的钩子函数，组件重新渲染前执行(shouldComponentUpdate =&gt; render)</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/shouldComponentUpdata.png" class="lozad post-image"src="images/shouldComponentUpdata.png"></p><h4 id="随机数案例"><a href="#随机数案例" class="headerlink" title="随机数案例"></a>随机数案例</h4><p>需求：随机生成数字，显示在页面，如果生成的数字与当前显示的数字相同，那么就不需要更新UI，反之更新UI。</p><p>利用nextState参数来判断当前组件是否需要更新</p><pre class="highlight"><span class="line">class App extends React.Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        number: 0</span><br><span class="line">    &#125;</span><br><span class="line">    // 点击事件，每次点击生成一个随机数</span><br><span class="line">    hanldeBtn = () =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            number: Math.floor(Math.random() * 3)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 将要更新UI的时候会执行这个钩子函数</span><br><span class="line">    shouldComponentUpdate(nextProps,nextState) &#123;</span><br><span class="line">         // 判断一下当前生成的 值是否与页面的值相等</span><br><span class="line">         if(nextState.number !== this.state.number)&#123;</span><br><span class="line">             return true</span><br><span class="line">         &#125;</span><br><span class="line">         return false</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                随机数：&#123;this.state.number&#125; &lt;br /&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.hanldeBtn&#125;&gt;生成随机数&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><p>利用props参数来判断是否需要进行更新</p><pre class="highlight"><span class="line">class App extends React.Component &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        number: 0</span><br><span class="line">    &#125;</span><br><span class="line">    // 点击事件，每次点击生成一个随机数</span><br><span class="line">    hanldeBtn = () =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            number: Math.floor(Math.random() * 3)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;NumberBox number=&#123;this.state.number&#125; /&gt;</span><br><span class="line">                &lt;button onClick=&#123;this.hanldeBtn&#125;&gt;生成随机数&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class NumberBox extends React.Component &#123;</span><br><span class="line">    // 将要更新UI的时候会执行这个钩子函数</span><br><span class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        // 判断一下当前生成的 值是否与页面的值相等</span><br><span class="line">        if (nextProps.number !== this.props.number) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1&gt;随机数：&#123;this.props.number&#125; &lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><h3 id="纯组件"><a href="#纯组件" class="headerlink" title="纯组件"></a>纯组件</h3><h4 id="作用以及使用"><a href="#作用以及使用" class="headerlink" title="作用以及使用"></a>作用以及使用</h4><ul><li>纯组件： PureComponent 与 React.Component 功能相似</li><li>区别： PureComponent 内部自动实现了 shouldComponentUpdate钩子，不需要手动比较</li><li>原理：纯组件内部通过分别比对前后两次 props和state的值，来决定是否重新渲染组件</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/PureComponent.png" class="lozad post-image"src="images/PureComponent.png"></p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>说明：纯组件内部的对比是 shallow compare（浅层对比）</li><li>对于值类型来说：比较两个值是否相同</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%AF%94%E5%AF%B9.png" class="lozad post-image"src="images/%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%AF%94%E5%AF%B9.png"></p><ul><li>引用类型：只比对对象的引用地址是否相同</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%AF%94%E5%AF%B9.png" class="lozad post-image"src="images/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%AF%94%E5%AF%B9.png"></p><ul><li>注意：state 或 props 中属性值为引用类型时，应该创建新数据，不要直接修改原数据</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%B3%A8%E6%84%8F%E7%82%B9.png" class="lozad post-image"src="images/%E6%B3%A8%E6%84%8F%E7%82%B9.png"></p><h2 id="虚拟DOM和Diff算法"><a href="#虚拟DOM和Diff算法" class="headerlink" title="虚拟DOM和Diff算法"></a>虚拟DOM和Diff算法</h2><ul><li>React更新视图的思想是：只要state变化就重新渲染视图</li><li>特点：思路非常清晰</li><li>问题：组件中只有一个DOM元素需要更新时，也得把整个组件的内容重新渲染吗？ 不是这样的</li><li>理想状态：部分更新，只更新变化的地方</li><li>React运用的核心点就是 虚拟DOM 配合 Diff 算法</li></ul><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>本质上就是一个JS对象，用来描述你希望在屏幕上看到的内容</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E8%99%9A%E6%8B%9FDOM.png" class="lozad post-image"src="images/%E8%99%9A%E6%8B%9FDOM.png"></p><h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><p>执行过程</p><ul><li>初次渲染时，React会根据初始化的state（model），创建一个虚拟DOM对象（树）</li><li>根据虚拟DOM生成真正的DOM，渲染到页面</li><li>当数据变化后(setState())，会重新根据新的数据，创建新的虚拟DOM对象（树）</li><li>与上一次得到的虚拟DOM对象，使用Diff算法比对（找不同），得到需要更新的内容</li><li>最终，React只将变化的内容更新（patch）到DOM中，重新渲染到页面</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/diff%E7%AE%97%E6%B3%95.png" class="lozad post-image"src="images/diff%E7%AE%97%E6%B3%95.png"></p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><ul><li>组件render()调用后，根据状态和JSX结构生成虚拟DOM对象(render()方法的调用并不意味着浏览器进行渲染，render方法调用时意味着Diff算法开始比对了)</li><li>示例中，只更新p元素的文本节点内容</li><li>初次渲染的DOM对象</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%88%9D%E6%AC%A1%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E5%AF%B9%E8%B1%A1.png" class="lozad post-image"src="images/%E5%88%9D%E6%AC%A1%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E5%AF%B9%E8%B1%A1.png"></p><ul><li>数据更新之后的虚拟DOM对象</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E5%AF%B9%E8%B1%A1.png" class="lozad post-image"src="images/%E6%9B%B4%E6%96%B0%E5%90%8E%E7%9A%84%E8%99%9A%E6%8B%9FDOM%E5%AF%B9%E8%B1%A1.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>工作角度：应用第一，原理第二</li><li>原理有助于更好的理解React的自身运行机制</li><li>setState() 异步更新数据</li><li>父组件更新导致子组件更新，纯组件提升性能</li><li>思路清晰简单为前提，虚拟DOM和Diff保效率（渲染变化的组件）</li><li>虚拟DOM -&gt; state + JSX</li><li>虚拟DOM最大的特点是 脱离了浏览器的束缚，也就是意味着只要是能支持js的地方都可以用到react，所以为什么说react是可以进行跨平台的开发</li></ul><h1 id="React路由基础"><a href="#React路由基础" class="headerlink" title="React路由基础"></a>React路由基础</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ul><li>能够说出React路由的作用</li><li>能够掌握-react-router-dom的基本使用</li><li>能够使用编程式导航跳转路由</li><li>能够知道React路由的匹配模式</li></ul><h2 id="React路由介绍"><a href="#React路由介绍" class="headerlink" title="React路由介绍"></a>React路由介绍</h2><p>现代的前端应用大多数是SPA（单页应用程序），也就是只有一个HTML页面的应用程序。因为它的用户体验更好、对服务器压力更小，所以更受欢迎。为了有效的使用单个页面来管理多页面的功能，前端路由应运而生。</p><ul><li>前端路由功能：让用户从一个视图（页面）导航到另一个视图（页面）</li><li>前端路由是一套映射规则，在React中，是URL路径与组件的对应关系</li><li>使用React路由简单来说，就是配置路径和组件</li></ul><h2 id="路由的基本使用"><a href="#路由的基本使用" class="headerlink" title="路由的基本使用"></a>路由的基本使用</h2><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li><p>安装： yarn add react-router-dom</p><ul><li>如果没有安装yarn工具的，需要先全局安装一下yarn：npm install -g yarn</li></ul></li><li><p>导入路由的三个核心组件： Router / Route / Link</p><pre class="highlight"><span class="line">import &#123;BrowserRouter as Router, Route, Link&#125; from &#x27;react-router-dom&#x27;</span><br></pre></li><li><p>使用Router 组件包裹整个应用</p></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/Router.png" class="lozad post-image"src="images/Router.png"></p><ul><li>使用Link组件作为导航菜单（路由入口）</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/link%E5%85%A5%E5%8F%A3.png" class="lozad post-image"src="images/link%E5%85%A5%E5%8F%A3.png"></p><ul><li>使用Route组件配置路由规则和要展示的组件（路由出口）</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/route.png" class="lozad post-image"src="images/route.png"></p><h3 id="常用组件说明"><a href="#常用组件说明" class="headerlink" title="常用组件说明"></a>常用组件说明</h3><ul><li><strong>Router组件：</strong>包裹整个应用，一个React应用只需要使用一次<ul><li>两种常用的Router： HashRouter和BrowserRouter</li><li>HashRouter： 使用URL的哈希值实现 （localhost:3000/#/first）</li><li>推荐 BrowserRouter：使用H5的history API实现（localhost3000/first）</li></ul></li><li><strong>Link组件：</strong>用于指定导航链接（a标签）<ul><li>最终Link会编译成a标签，而to属性会被编译成 a标签的href属性</li></ul></li><li><strong>Route组件：</strong>指定路由展示组件相关信息<ul><li>path属性：路由规则，这里需要跟Link组件里面to属性的值一致</li><li>component属性：展示的组件</li><li>Route写在哪，渲染出来的组件就在哪</li></ul></li></ul><h3 id="路由的执行过程"><a href="#路由的执行过程" class="headerlink" title="路由的执行过程"></a>路由的执行过程</h3><ul><li>当我们点击Link组件的时候，修改了浏览器地址栏中的url</li><li>React路由监听地址栏url的变化</li><li>React路由内部遍历所有的Route组件，拿着Route里面path规则与pathname进行匹配</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/route%E5%8C%B9%E9%85%8D.png" class="lozad post-image"src="images/route%E5%8C%B9%E9%85%8D.png"></p><ul><li>当路由规则（path）能够匹配地址栏中的pathname时，就展示该Route组件的内容</li></ul><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><ul><li><strong>场景：</strong>点击登陆按钮，登陆成功后，通过代码跳转到后台首页，如何实现？</li><li><strong>编程式导航：</strong>通过JS代码来实现页面跳转</li><li>history是React路由提供的，用于获取浏览器历史记录的相关信息</li><li><strong>push(path)：</strong>跳转到某个页面，参数path表示要跳转的路径</li><li>go(n)：前进或后退功能，参数n表示前进或后退页面数量</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA.png" class="lozad post-image"src="images/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA.png"></p><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><ul><li>现在的路由都是通过点击导航菜单后展示的，如果进入页面的时候就主动触发路由呢</li><li>默认路由：表示进入页面时就会匹配的路由</li><li>默认路由：只需要把path设置为 <code>&#39;/&#39;</code></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1.png" class="lozad post-image"src="images/%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1.png"></p><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><h4 id="模糊匹配模式"><a href="#模糊匹配模式" class="headerlink" title="模糊匹配模式"></a>模糊匹配模式</h4><ul><li>当Link组件的to属性值为 ‘/login’ 时候，为什么默认路由也被匹配成功？</li><li>默认情况下，React路由是模糊匹配模式</li><li>模糊匹配规则：只要pathname以path开头就会匹配成功</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F.png" class="lozad post-image"src="images/%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F.png"></p><h4 id="精准匹配"><a href="#精准匹配" class="headerlink" title="精准匹配"></a>精准匹配</h4><ul><li>默认路由认可情况下都会展示，如果避免这种问题？</li><li>给Route组件添加exact属性，让其变为<strong>精准匹配模式</strong></li><li>精确匹配：只有当path和pathname完全匹配时才会展示改路由</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D.png" class="lozad post-image"src="images/%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D.png"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>React路由可以有效的管理多个视图实现 SPA</li><li>路由先需要通过安装</li><li>Router组件包裹整个应用，只需要使用一次</li><li>Link组件是入口，Route组件是出口</li><li>通过props.history实现编程式导航</li><li>默认是模糊匹配，添加exact编程精确匹配</li><li>React路由的一切都是组件，可以像思考组件一样思考路由</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React原理揭秘&quot;&gt;&lt;a href=&quot;#React原理揭秘&quot; class=&quot;headerlink&quot; title=&quot;React原理揭秘&quot;&gt;&lt;/a&gt;React原理揭秘&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/04/24/react%E5%9F%BA%E7%A1%80Day02-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6&amp;%E8%AF%84%E8%AE%BA%E6%A1%88%E4%BE%8B&amp;props&amp;context/"/>
    <id>http://example.com/2023/04/24/react%E5%9F%BA%E7%A1%80Day02-%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6&amp;%E8%AF%84%E8%AE%BA%E6%A1%88%E4%BE%8B&amp;props&amp;context/</id>
    <published>2023-04-24T09:02:02.468Z</published>
    <updated>2023-04-24T11:42:23.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>能够知道受控组件是什么</li><li>能够写出受控组件</li><li>了解非受控组件</li></ul><h2 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h2><h3 id="受控组件（★★★）"><a href="#受控组件（★★★）" class="headerlink" title="受控组件（★★★）"></a>受控组件（★★★）</h3><ul><li>HTML中的表单元素是可输入的，也就是有自己的可变状态</li><li>而React中可变状态通常保存在state中，并且只能通过 <code>setState()</code> 方法来修改</li><li>React讲state与表单元素值value绑定在一起，有state的值来控制表单元素的值</li><li>受控组件：值受到react控制的表单元素</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6.png" class="lozad post-image"src="images/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6.png"></p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li>在state中添加一个状态，作为表单元素的value值</li><li>给表单元素绑定change事件，将表单元素的值设置为state的值</li></ul><h4 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h4><pre class="highlight"><span class="line">class App extends React.Component &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">        this.inputChange = this.inputChange.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">    state = &#123;</span><br><span class="line">        txt : &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    inputChange(e)&#123;</span><br><span class="line">       this.setState(&#123;</span><br><span class="line">           txt: e.target.value</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        console.log(this.state);</span><br><span class="line">    </span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;/* 把state的值设置给输入框的value，绑定change事件，这样用户在输入内容的时候调用相应函数，在函数里面把当前设置的值赋值给state，从而达到数据的统一 */&#125;</span><br><span class="line">                &lt;input type=&quot;text&quot; value=&#123;this.state.txt&#125; onChange=&#123;this.inputChange&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;,document.getElementById(&#x27;root&#x27;))</span><br></pre><h4 id="多表单元素优化"><a href="#多表单元素优化" class="headerlink" title="多表单元素优化"></a>多表单元素优化</h4><ul><li>问题：每个表单元素都有一个单独的事件处理函数，这样太繁琐</li><li>优化：使用一个事件处理程序同时处理多个表单元素</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>给表单元素添加name属性（用来区分是哪一个表单），名称与state相同（用来更新数据的）</li><li>根据表单内容来获取对应值</li><li>在change事件处理程序中通过 [name] 来修改对应的state</li></ul><h5 id="示例demo-1"><a href="#示例demo-1" class="headerlink" title="示例demo"></a>示例demo</h5><pre class="highlight"><span class="line">inputChange(e)&#123;</span><br><span class="line">   let target = e.target;</span><br><span class="line">   let value = target.type == &#x27;checkbox&#x27; ? target.checked : target.value;</span><br><span class="line">   this.setState(&#123;</span><br><span class="line">       [e.target.name]: value</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;input type=&quot;text&quot; value=&#123;this.state.txt&#125; name=&quot;txt&quot; onChange=&#123;this.inputChange&#125;/&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; value=&#123;this.state.isChecked&#125; name=&quot;isChecked&quot; onChange=&#123;this.inputChange&#125;/&gt;</span><br></pre><h3 id="非受控组件-（了解）"><a href="#非受控组件-（了解）" class="headerlink" title="非受控组件 （了解）"></a>非受控组件 （了解）</h3><ul><li>说明：借助于ref，使用元素DOM方式获取表单元素值</li><li>ref的作用：获取DOM或者组件</li></ul><h4 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li>调用 <code>React.createRef()</code> 方法创建ref对象</li><li>将创建好的 ref 对象添加到文本框中</li><li>通过ref对象获取到文本框的值</li></ul><pre class="highlight"><span class="line">class App extends React.Component &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">    </span><br><span class="line">        //创建 ref</span><br><span class="line">        this.txtRef = React.createRef()</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取文本框的值</span><br><span class="line">    getTxt =() =&gt; &#123;</span><br><span class="line">        console.log(this.txtRef.current.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;input type =&quot;text&quot; ref=&#123;this.txtRef&#125; /&gt;</span><br><span class="line">            &lt;button onClick =&#123;this.getTxt&#125;&gt;获取值&lt;/button&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><h1 id="React组件综合案例（★★★）"><a href="#React组件综合案例（★★★）" class="headerlink" title="React组件综合案例（★★★）"></a>React组件综合案例（★★★）</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>渲染评论列表（列表渲染）</li><li>没有评论数据时渲染：暂无评论（条件渲染）</li><li>获取评论信息，包括评论人和评论内容（受控组件）</li><li>发表评论，更新评论列表（<code>setState()</code>）</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B.png" class="lozad post-image"src="images/%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B.png"></p><h2 id="搭建评论列表的模板"><a href="#搭建评论列表的模板" class="headerlink" title="搭建评论列表的模板"></a>搭建评论列表的模板</h2><ul><li>结构</li></ul><pre class="highlight"><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">  评论列表案例</span><br><span class="line"></span><br><span class="line">  comments: [</span><br><span class="line">    &#123; id: 1, name: &#x27;jack&#x27;, content: &#x27;沙发！！！&#x27; &#125;,</span><br><span class="line">    &#123; id: 2, name: &#x27;rose&#x27;, content: &#x27;板凳~&#x27; &#125;,</span><br><span class="line">    &#123; id: 3, name: &#x27;tom&#x27;, content: &#x27;楼主好人&#x27; &#125;</span><br><span class="line">  ]</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">import &#x27;./index.css&#x27;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;app&quot;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input className=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;请输入评论人&quot; /&gt;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          &lt;textarea</span><br><span class="line">            className=&quot;content&quot;</span><br><span class="line">            cols=&quot;30&quot;</span><br><span class="line">            rows=&quot;10&quot;</span><br><span class="line">            placeholder=&quot;请输入评论内容&quot;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          &lt;button&gt;发表评论&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div className=&quot;no-comment&quot;&gt;暂无评论，快去评论吧~&lt;/div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li&gt;</span><br><span class="line">            &lt;h3&gt;评论人：jack&lt;/h3&gt;</span><br><span class="line">            &lt;p&gt;评论内容：沙发！！！&lt;/p&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 渲染组件</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;))</span><br></pre><ul><li>样式</li></ul><pre class="highlight"><span class="line"><span class="selector-class">.app</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.user</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.no-comment</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre><h2 id="渲染评论列表"><a href="#渲染评论列表" class="headerlink" title="渲染评论列表"></a>渲染评论列表</h2><ul><li>在state中初始化评论列表数据</li></ul><pre class="highlight"><span class="line">state = &#123;</span><br><span class="line">  comments: [</span><br><span class="line">    &#123; id: 1, name: &#x27;jack&#x27;, content: &#x27;沙发！！！&#x27; &#125;,</span><br><span class="line">    &#123; id: 2, name: &#x27;rose&#x27;, content: &#x27;板凳~&#x27; &#125;,</span><br><span class="line">    &#123; id: 3, name: &#x27;tom&#x27;, content: &#x27;楼主好人&#x27; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre><ul><li>使用数组的map方法遍历state中的列表数据</li><li>给每一个被遍历的li元素添加key属性</li><li>在render方法里的ul节点下嵌入表达式</li></ul><pre class="highlight"><span class="line">&#123;</span><br><span class="line">  this.state.comments.map(item =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">       &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;h3&gt;&#123;item.name&#125;&lt;/h3&gt;</span><br><span class="line">          &lt;p&gt;&#123;item.content&#125;&lt;/p&gt;</span><br><span class="line">       &lt;/li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre><h2 id="渲染暂无评论"><a href="#渲染暂无评论" class="headerlink" title="渲染暂无评论"></a>渲染暂无评论</h2><ul><li>判断列表数据的长度是否为0</li><li>如果为0，则渲染暂无评论</li><li>如果不为0，那么渲染列表数据</li><li>在jsx中大量写逻辑会导致很臃肿，所以我们可以把条件渲染的逻辑抽取成一个函数</li></ul><pre class="highlight"><span class="line">/**</span><br><span class="line"> * 条件渲染，这里抽取出来了，这样在结构中不会很混乱</span><br><span class="line"> */</span><br><span class="line">renderList()&#123;</span><br><span class="line">  if (this.state.comments.length === 0) &#123;</span><br><span class="line">    return (&lt;div className=&quot;no-comment&quot;&gt;暂无评论，快去评论吧~&lt;/div&gt;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;ul&gt; &#123;</span><br><span class="line">        this.state.comments.map(item =&gt; &#123;</span><br><span class="line">          return (</span><br><span class="line">            &lt;li key=&#123;item.id&#125;&gt;</span><br><span class="line">              &lt;h3&gt;&#123;item.name&#125;&lt;/h3&gt;</span><br><span class="line">              &lt;p&gt;&#123;item.content&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre><ul><li>在render的return方法里面调用这个函数即可</li></ul><pre class="highlight"><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      ...</span><br><span class="line">      &#123;/* 通过条件渲染来判断是否显示暂无评论 */&#125;</span><br><span class="line">      &#123;this.renderList()&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre><h2 id="获取评论信息"><a href="#获取评论信息" class="headerlink" title="获取评论信息"></a>获取评论信息</h2><ul><li>通过受控组件来获取内容</li><li>初始化用户名和用户内容的state</li></ul><pre class="highlight"><span class="line">userName: &#x27;&#x27;,</span><br><span class="line">userContent: &#x27;&#x27;</span><br></pre><ul><li>在结构中，把表单元素的value与state进行绑定，还需要绑定name属性和onChange属性</li></ul><pre class="highlight"><span class="line">&lt;input className=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;请输入评论人&quot; value=&#123;this.state.userName&#125; name=&quot;userName&quot; onChange=&#123;this.handleForm&#125;/&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;textarea</span><br><span class="line">  className=&quot;content&quot;</span><br><span class="line">  cols=&quot;30&quot;</span><br><span class="line">  rows=&quot;10&quot;</span><br><span class="line">  placeholder=&quot;请输入评论内容&quot;</span><br><span class="line">  value=&#123;this.state.userContent&#125;</span><br><span class="line">  name=&quot;userContent&quot;</span><br><span class="line">  onChange=&#123;this.handleForm&#125;</span><br><span class="line">/&gt;</span><br></pre><ul><li>在 <code>handleFrom</code>函数中利用 <code>setState</code>来让数据保持一致</li></ul><pre class="highlight"><span class="line">handleForm = (e) =&gt; &#123;</span><br><span class="line">   this.setState(&#123;</span><br><span class="line">     [e.target.name] : e.target.value</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre><h2 id="发表评论"><a href="#发表评论" class="headerlink" title="发表评论"></a>发表评论</h2><ul><li>给按钮绑定事件</li><li>在事件处理程序中，通过state获取评论信息</li><li>将评论信息添加到state中，利用setState来更新页面</li><li>添加评论前需要判断用户是否输入内容</li><li>添加评论后，需要情况文本框用户输入的值</li></ul><pre class="highlight"><span class="line">handleClick = (e) =&gt; &#123;</span><br><span class="line">  // 拿到用户输入的内容</span><br><span class="line">  let &#123;userName,userContent&#125; = this.state</span><br><span class="line">  if(userName.trim()===&#x27;&#x27; || userContent.trim() === &#x27;&#x27;)&#123;</span><br><span class="line">      alert(&#x27;请输入内容&#x27;)</span><br><span class="line">      return</span><br><span class="line">  &#125;</span><br><span class="line">  // 利用数组拓展运算符来进行数据的拼接，把用户输入的存放在数组的第一个位置</span><br><span class="line">  let newComments = [&#123;</span><br><span class="line">    id: this.state.comments.length+1,</span><br><span class="line">    name: userName,</span><br><span class="line">    content: userContent</span><br><span class="line">  &#125;,...this.state.comments]</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    comments: newComments,</span><br><span class="line">    userName:&#x27;&#x27;,</span><br><span class="line">    userContent: &#x27;&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre><h1 id="React组件进阶"><a href="#React组件进阶" class="headerlink" title="React组件进阶"></a>React组件进阶</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ul><li>能够使用props接收数据</li><li>能够实现父子组件之间的通讯</li><li>能够实现兄弟组件之间的通讯</li><li>能够给组件添加props校验</li></ul><h2 id="组件通讯介绍"><a href="#组件通讯介绍" class="headerlink" title="组件通讯介绍"></a>组件通讯介绍</h2><p>组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能拆分成多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据。为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通，这个过程就是组件通讯</p><h2 id="组件的props（★★★）"><a href="#组件的props（★★★）" class="headerlink" title="组件的props（★★★）"></a>组件的props（★★★）</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ul><li>组件时封闭的，要接受外部数据应该通过props来实现</li><li>props的作用：接收传递给组件的数据</li><li>传递数据：给组件标签添加属性</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/props-%E8%AE%BE%E7%BD%AE.png" class="lozad post-image"src="images/props-%E8%AE%BE%E7%BD%AE.png"></p><ul><li><p>接收数据：函数组件通过 参数 props接收数据，类组件通过 this.props接收数据</p><ul><li><p>函数组件获取</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96.png" class="lozad post-image"src="images/%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96.png"></p></li><li><p>类组件获取</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%B1%BB%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96.png" class="lozad post-image"src="images/%E7%B1%BB%E7%BB%84%E4%BB%B6%E8%8E%B7%E5%8F%96.png"></p></li></ul></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>可以给组件传递任意类型的数据</li><li>props是只读属性，不能对值进行修改</li><li>注意：使用类组件时，如果写了构造函数，应该将props传递给super(),否则，无法在构造函数中获取到props，其他的地方是可以拿到的</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%B3%A8%E6%84%8F%E7%82%B9.png" class="lozad post-image"src="images/%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%B3%A8%E6%84%8F%E7%82%B9.png"></p><h2 id="组件通讯的三种方式（★★★）"><a href="#组件通讯的三种方式（★★★）" class="headerlink" title="组件通讯的三种方式（★★★）"></a>组件通讯的三种方式（★★★）</h2><h3 id="父组件传递数据给子组件"><a href="#父组件传递数据给子组件" class="headerlink" title="父组件传递数据给子组件"></a>父组件传递数据给子组件</h3><ul><li>父组件提供要传递的state数据</li><li>给子组件标签添加属性，值为state中的数据</li><li>子组件中通过props接收父组件中传递的数据</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%88%B6%E4%BC%A0%E5%AD%90.png" class="lozad post-image"src="images/%E7%88%B6%E4%BC%A0%E5%AD%90.png"></p><h3 id="子组件传递数据给父组件"><a href="#子组件传递数据给父组件" class="headerlink" title="子组件传递数据给父组件"></a>子组件传递数据给父组件</h3><ul><li>利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数</li><li>父组件提供一个回调函数，用来接收数据</li><li>将该函数作为属性的值，传递给子组件</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%AD%90%E4%BC%A0%E7%88%B6-%E7%88%B6%E4%BA%B2%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%B0%83.png" class="lozad post-image"src="images/%E5%AD%90%E4%BC%A0%E7%88%B6-%E7%88%B6%E4%BA%B2%E8%AE%BE%E7%BD%AE%E5%9B%9E%E8%B0%83.png"></p><ul><li>子组件通过props调用回调函数</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%AD%90%E4%BC%A0%E7%88%B6-%E8%B0%83%E7%94%A8%E5%9B%9E%E8%B0%83.png" class="lozad post-image"src="images/%E5%AD%90%E4%BC%A0%E7%88%B6-%E8%B0%83%E7%94%A8%E5%9B%9E%E8%B0%83.png"></p><h3 id="兄弟组件传递"><a href="#兄弟组件传递" class="headerlink" title="兄弟组件传递"></a>兄弟组件传递</h3><ul><li>将共享状态(数据)提升到最近的公共父组件中，由公共父组件管理这个状态</li><li>这个称为状态提升</li><li>公共父组件职责：1. 提供共享状态 2.提供操作共享状态的方法</li><li>要通讯的子组件只需要通过props接收状态或操作状态的方法</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%85%84%E5%BC%9F%E4%BC%A0%E9%80%92.png" class="lozad post-image"src="images/%E5%85%84%E5%BC%9F%E4%BC%A0%E9%80%92.png"></p><h4 id="示例demo-2"><a href="#示例demo-2" class="headerlink" title="示例demo"></a>示例demo</h4><ul><li>定义布局结构，一个Counter里面包含两个子组件，一个是计数器的提示，一个是按钮</li></ul><pre class="highlight"><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (&lt;div&gt;</span><br><span class="line">            &lt;Child1 /&gt;</span><br><span class="line">            &lt;Child2 /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child1 extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1&gt;计数器：&lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child2 extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button&gt;+1&lt;/button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><ul><li>在父组件里定义共享状态，把这个状态传递给第一个子组件</li></ul><pre class="highlight"><span class="line">class Counter extends React.Component &#123;</span><br><span class="line">    // 提供共享的状态</span><br><span class="line">    state = &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (&lt;div&gt;</span><br><span class="line">            &#123;/* 把状态提供给第一个子组件 */&#125;</span><br><span class="line">            &lt;Child1 count=&#123;this.state.count&#125;/&gt;</span><br><span class="line">            &lt;Child2 /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><ul><li>在第一个子组件里面就能通过props获取到</li></ul><pre class="highlight"><span class="line">class Child1 extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1&gt;计数器：&#123;this.props.count&#125;&lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><ul><li>在父组件中提供共享方法，通过属性传递给第二个子组件，方便第二个子组件来进行调用</li></ul><pre class="highlight"><span class="line">// 提供共享方法</span><br><span class="line">onIncrement = (res) =&gt; &#123;</span><br><span class="line">    // 只要第二个子组件调用了这个函数，就会执行里面代码</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        count: this.state.count + res</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">    return (&lt;div&gt;</span><br><span class="line">        ...</span><br><span class="line">        &#123;/* 把共享方法提供给第二个子组件 */&#125;</span><br><span class="line">        &lt;Child2 onIncrement=&#123;this.onIncrement&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre><ul><li>在第二个子组件里面通过props来获取到对应函数，然后进行调用</li></ul><pre class="highlight"><span class="line">class Child2 extends React.Component &#123;</span><br><span class="line">    handleClick = () =&gt; &#123;</span><br><span class="line">        // 这里一旦调用，就会执行父组件里面 onIncrement函数</span><br><span class="line">        this.props.onIncrement(2)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><h2 id="Context（★★★）"><a href="#Context（★★★）" class="headerlink" title="Context（★★★）"></a>Context（★★★）</h2><p>如果出现层级比较多的情况下（例如：爷爷传递数据给孙子），我们会使用Context来进行传递</p><p>作用： 跨组件传递数据</p><h3 id="使用步骤-2"><a href="#使用步骤-2" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li>调用 <code>React.createContext()</code> 创建 Provider(提供数据) 和 Consumer(消费数据) 两个组件</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%88%9B%E5%BB%BAContext.png" class="lozad post-image"src="images/%E5%88%9B%E5%BB%BAContext.png"></p><ul><li>使用Provider 组件作为父节点</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/provider.png" class="lozad post-image"src="images/provider.png"></p><ul><li>设置value属性，表示要传递的数据</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E8%AE%BE%E7%BD%AEvalue%E5%B1%9E%E6%80%A7.png" class="lozad post-image"src="images/%E8%AE%BE%E7%BD%AEvalue%E5%B1%9E%E6%80%A7.png"></p><ul><li>哪一层想要接收数据，就用Consumer进行包裹，在里面回调函数中的参数就是传递过来的值</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/Comsumer.png" class="lozad post-image"src="images/Comsumer.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>如果两个组件相隔层级比较多，可以使用Context实现组件通讯</li><li>Context提供了两个组件：Provider 和 Consumer</li><li>Provider组件： 用来提供数据</li><li>Consumer组件： 用来消费数据</li></ul><h2 id="props进阶"><a href="#props进阶" class="headerlink" title="props进阶"></a>props进阶</h2><h3 id="children属性"><a href="#children属性" class="headerlink" title="children属性"></a>children属性</h3><ul><li>children属性： 表示组件标签的子节点，当组件标签有子节点时，props就会有该属性</li><li>children属性与普通的props一样，值可以使任意值（文本、react元素、组件、甚至是函数）</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/props-children.png" class="lozad post-image"src="images/props-children.png"></p><h3 id="props校验（★★★）"><a href="#props校验（★★★）" class="headerlink" title="props校验（★★★）"></a>props校验（★★★）</h3><ul><li>对于组件来说，props是外来的，无法保证组件使用者传入什么格式的数据，简单来说就是组件调用者可能不知道组件封装着需要什么样的数据</li><li>如果传入的数据不对，可能会导致报错</li><li>关键问题：组件的使用者不知道需要传递什么样的数据</li><li>props校验：允许在创建组件的时候，指定props的类型、格式等</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/props-%E6%A0%A1%E9%AA%8C.png" class="lozad post-image"src="images/props-%E6%A0%A1%E9%AA%8C.png"></p><ul><li>作用：捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/props-%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA.png" class="lozad post-image"src="images/props-%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA.png"></p><h4 id="使用步骤-3"><a href="#使用步骤-3" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li>安装包  <code>prop-types (yarn add prop-types | npm i props-types)</code></li><li>导入prop-types 包</li><li>使用 <code>组件名.propTypes=&#123;&#125;</code> 来给组件的props添加校验规则</li><li>校验规则通过PropTypes对象来指定</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/propsTypes.png" class="lozad post-image"src="images/propsTypes.png"></p><h4 id="常见的约束规则"><a href="#常见的约束规则" class="headerlink" title="常见的约束规则"></a>常见的约束规则</h4><ul><li>创建的类型： <code>array、bool、func、number、object、string</code></li><li>React元素类型：<code>element</code></li><li>必填项：<code>isRequired</code></li><li>特定结构的对象： <code>shape(&#123;&#125;)</code></li><li>更多的<a href="https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#proptypes">约束规则</a></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/props-%E7%BA%A6%E6%9D%9F%E8%A7%84%E5%88%99.png" class="lozad post-image"src="images/props-%E7%BA%A6%E6%9D%9F%E8%A7%84%E5%88%99.png"></p><h3 id="props的默认值"><a href="#props的默认值" class="headerlink" title="props的默认值"></a>props的默认值</h3><ul><li>场景：分页组件 -&gt; 每页显示条数</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/props%E9%BB%98%E8%AE%A4%E5%80%BC.png" class="lozad post-image"src="images/props%E9%BB%98%E8%AE%A4%E5%80%BC.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React组件&quot;&gt;&lt;a href=&quot;#React组件&quot; class=&quot;headerlink&quot; title=&quot;React组件&quot;&gt;&lt;/a&gt;React组件&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/04/24/react%E5%9F%BA%E7%A1%80Day03-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;render%20props%E6%A8%A1%E5%BC%8F&amp;%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6&amp;%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98/"/>
    <id>http://example.com/2023/04/24/react%E5%9F%BA%E7%A1%80Day03-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;render%20props%E6%A8%A1%E5%BC%8F&amp;%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6&amp;%E5%8E%9F%E7%90%86%E6%8F%AD%E7%A7%98/</id>
    <published>2023-04-24T09:01:45.809Z</published>
    <updated>2023-04-24T11:42:26.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件生命周期（★★★）"><a href="#组件生命周期（★★★）" class="headerlink" title="组件生命周期（★★★）"></a>组件生命周期（★★★）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>说出组件生命周期对应的钩子函数</li><li>钩子函数调用的时机</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>意义：组件的生命周期有助于理解组件的运行方式，完成更复杂的组件功能、分析组件错误原因等</p><p>组件的生命周期： 组件从被创建到挂载到页面中运行，再到组件不在时卸载的过程</p><p>生命周期的每个阶段总是伴随着一些方法调用，这些方法就是生命周期的钩子函数</p><p>构造函数的作用：为开发人员在不同阶段操作组件提供了实际</p><h2 id="生命周期阶段"><a href="#生命周期阶段" class="headerlink" title="生命周期阶段"></a>生命周期阶段</h2><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="lozad post-image"src="images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><h3 id="创建时（挂载阶段）"><a href="#创建时（挂载阶段）" class="headerlink" title="创建时（挂载阶段）"></a>创建时（挂载阶段）</h3><ul><li>执行时机：组件创建时（页面加载时）</li><li>执行顺序</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%88%9B%E5%BB%BA%E6%97%B6-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="lozad post-image"src="images/%E5%88%9B%E5%BB%BA%E6%97%B6-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png"></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%88%9B%E5%BB%BA%E6%97%B6-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8.png" class="lozad post-image"src="images/%E5%88%9B%E5%BB%BA%E6%97%B6-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p><h3 id="更新时"><a href="#更新时" class="headerlink" title="更新时"></a>更新时</h3><p>执行时机：<code>setState()、 forceUpdate()、 组件接收到新的props</code></p><p>说明：以上三者任意一种变化，组件就会重新渲染</p><p>执行顺序：</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%9B%B4%E6%96%B0%E6%97%B6.png" class="lozad post-image"src="images/%E6%9B%B4%E6%96%B0%E6%97%B6.png"></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%9B%B4%E6%96%B0%E6%97%B6-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8.png" class="lozad post-image"src="images/%E6%9B%B4%E6%96%B0%E6%97%B6-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8.png"></p><h3 id="卸载时"><a href="#卸载时" class="headerlink" title="卸载时"></a>卸载时</h3><p>执行时机：组件从页面中消失</p><p>作用：用来做清理操作</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E5%8D%B8%E8%BD%BD%E6%97%B6.png" class="lozad post-image"src="images/%E5%8D%B8%E8%BD%BD%E6%97%B6.png"></p><h3 id="不常用的钩子函数"><a href="#不常用的钩子函数" class="headerlink" title="不常用的钩子函数"></a>不常用的钩子函数</h3><h4 id="旧版的生命周期钩子函数"><a href="#旧版的生命周期钩子函数" class="headerlink" title="旧版的生命周期钩子函数"></a>旧版的生命周期钩子函数</h4><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%97%A7%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png" class="lozad post-image"src="images/%E6%97%A7%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png"></p><h4 id="新版完整生命会走棋钩子函数"><a href="#新版完整生命会走棋钩子函数" class="headerlink" title="新版完整生命会走棋钩子函数"></a>新版完整生命会走棋钩子函数</h4><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%96%B0%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png" class="lozad post-image"src="images/%E6%96%B0%E7%89%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.png"></p><h5 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps()"></a><code>getDerivedStateFromProps()</code></h5><ul><li><strong><code>getDerivedStateFromProps</code></strong> 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容</li><li>不管原因是什么，都会在<em>每次</em>渲染前触发此方法</li></ul><h5 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a><code>shouldComponentUpdate()</code></h5><ul><li>根据 <strong><code>shouldComponentUpdate()</code></strong> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染</li><li>当 props 或 state 发生变化时，**<code>shouldComponentUpdate()</code>** 会在渲染执行之前被调用。返回值默认为 true</li></ul><h5 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate()"></a><code>getSnapshotBeforeUpdate()</code></h5><ul><li><strong><code>getSnapshotBeforeUpdate()</code></strong> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <strong><code>componentDidUpdate()</code></strong></li><li>此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等</li></ul><h1 id="render-props模式-（★★★）"><a href="#render-props模式-（★★★）" class="headerlink" title="render-props模式 （★★★）"></a>render-props模式 （★★★）</h1><h2 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h2><ul><li>知道render-props模式有什么作用</li><li>能够说出render-props的使用步骤</li></ul><h2 id="React组件复用概述"><a href="#React组件复用概述" class="headerlink" title="React组件复用概述"></a>React组件复用概述</h2><ul><li>思考：如果两个组件中的部分功能相似或相同，该如何处理？</li><li>处理方式：复用相似的功能</li><li>复用什么？<ul><li>state</li><li>操作state的方法</li></ul></li><li>两种方式：<ul><li>render props模式</li><li>高阶组件（HOC）</li></ul></li><li>注意： 这两种方式不是新的API，而是利用React自身特点的编码技巧，演化而成的固定模式</li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><ul><li><p>思路：将要复用的state和操作state的方法封装到一个组件中</p></li><li><p>如何拿到该组件中复用的state</p><ul><li><p>在使用组件时，添加一个值为函数的prop，通过函数参数来获取</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/render-props-01.png" class="lozad post-image"src="images/render-props-01.png"></p></li></ul></li><li><p>如何渲染到任意的UI</p><ul><li><p>使用该函数的返回值作为要渲染的UI内容</p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/render-props-02.png" class="lozad post-image"src="images/render-props-02.png"></p></li></ul></li></ul><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li>创建Mouse组件，在组件中提供复用的逻辑代码</li><li>将要复用的状态作为 props.render(state)方法的参数，暴露到组件外部</li><li>使用props.render() 的返回值作为要渲染的内容</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/render-props%E6%A8%A1%E5%BC%8F-01.png" class="lozad post-image"src="images/render-props%E6%A8%A1%E5%BC%8F-01.png"></p><h4 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h4><pre class="highlight"><span class="line">class Mouse extends React.Component &#123;</span><br><span class="line">    // 鼠标位置状态</span><br><span class="line">    state = &#123;</span><br><span class="line">        x: 0,</span><br><span class="line">        y: 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 监听鼠标移动事件</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        window.addEventListener(&#x27;mousemove&#x27;,this.handleMouseMove)</span><br><span class="line">    &#125;</span><br><span class="line">    handleMouseMove = e =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            x: e.clientX,</span><br><span class="line">            y: e.clientY</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        // 向外界提供当前子组件里面的数据</span><br><span class="line">        return this.props.render(this.state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                App</span><br><span class="line">                &lt;Mouse render=&#123;mouse =&gt; &#123;</span><br><span class="line">                    return &lt;p&gt;X&#123;mouse.x&#125;Y&#123;mouse.y&#125;&lt;/p&gt;</span><br><span class="line">                &#125;&#125;/&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;,document.getElementById(&#x27;root&#x27;))</span><br></pre><h2 id="children代替render属性"><a href="#children代替render属性" class="headerlink" title="children代替render属性"></a>children代替render属性</h2><ul><li>注意：并不是该模式叫 render props就必须使用名为render的prop，实际上可以使用任意名称的prop</li><li>把prop是一个函数并且告诉组件要渲染什么内容的技术叫做： render props模式</li><li>推荐：使用childre代替render属性</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/render-props-children%E6%A8%A1%E5%BC%8F.png" class="lozad post-image"src="images/render-props-children%E6%A8%A1%E5%BC%8F.png"></p><h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><ul><li>推荐给render props模式添加props校验</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E4%BC%98%E5%8C%96-%E6%B7%BB%E5%8A%A0%E6%A0%A1%E9%AA%8C.png" class="lozad post-image"src="images/%E4%BC%98%E5%8C%96-%E6%B7%BB%E5%8A%A0%E6%A0%A1%E9%AA%8C.png"></p><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E4%BC%98%E5%8C%96-%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A.png" class="lozad post-image"src="images/%E4%BC%98%E5%8C%96-%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A.png"></p><h1 id="高阶组件-（★★★）"><a href="#高阶组件-（★★★）" class="headerlink" title="高阶组件 （★★★）"></a>高阶组件 （★★★）</h1><h2 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h2><ul><li>知道高阶组件的作用</li><li>能够说出高阶的使用步骤</li></ul><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ul><li>目的：实现状态逻辑复用</li><li>采用 包装模式</li><li>手机：获取保护功能</li><li>手机壳：提供保护功能</li><li>高阶组件就相当于手机壳，通过包装组件，增强组件功能</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%89%8B%E6%9C%BA%E5%A3%B3.png" class="lozad post-image"src="images/%E6%89%8B%E6%9C%BA%E5%A3%B3.png"></p><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><ul><li>高阶组件(HOC、Higher-Order Component) 是一个函数，接收要包装的组件，返回增强后的组件</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-%E5%87%BD%E6%95%B0.png" class="lozad post-image"src="images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-%E5%87%BD%E6%95%B0.png"></p><ul><li>高阶组件内部创建了一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给被包装组件 <code>WrappedComponent</code></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0.png" class="lozad post-image"src="images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0.png"></p><h2 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li>创建一个函数，名称约定以with开头</li><li>指定函数参数，参数应该以大写字母开头</li><li>在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回</li><li>在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件</li><li>调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面</li></ul><p><strong>包装函数</strong></p><pre class="highlight"><span class="line">// 定义一个函数，在函数内部创建一个相应类组件</span><br><span class="line">function withMouse(WrappedComponent) &#123;</span><br><span class="line">    // 该组件提供复用状态逻辑</span><br><span class="line">    class Mouse extends React.Component &#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            x: 0,</span><br><span class="line">            y: 0</span><br><span class="line">        &#125;</span><br><span class="line">        // 事件的处理函数</span><br><span class="line">        handleMouseMove = (e) =&gt; &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                x: e.clientX,</span><br><span class="line">                y: e.clientY</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        // 当组件挂载的时候进行事件绑定</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            window.addEventListener(&#x27;mousemove&#x27;, this.handleMouseMove)</span><br><span class="line">        &#125;</span><br><span class="line">        // 当组件移除时候解绑事件</span><br><span class="line">        componentWillUnmount() &#123;</span><br><span class="line">            window.removeEventListener(&#x27;mousemove&#x27;, this.handleMouseMove)</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            // 在render函数里面返回传递过来的组件，把当前组件的状态设置进去</span><br><span class="line">            return &lt;WrappedComponent &#123;...this.state&#125; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Mouse</span><br><span class="line">&#125;</span><br></pre><p><strong>哪个组件需要加强，通过调用 <code>withMouse</code>这个函数，然后把返回的值设置到父组件中即可</strong></p><pre class="highlight"><span class="line">function Position(props) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            X:&#123;props.x&#125;</span><br><span class="line">            Y:&#123;props.y&#125;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">// 把position 组件来进行包装</span><br><span class="line">let MousePosition = withMouse(Position)</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                高阶组件</span><br><span class="line">                &lt;MousePosition&gt;&lt;/MousePosition&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><h2 id="设置-displayName"><a href="#设置-displayName" class="headerlink" title="设置 displayName"></a>设置 <code>displayName</code></h2><ul><li>使用高阶组件存在的问题：得到两个组件的名称相同</li><li>原因：默认情况下，React使用组件名称作为 <code>displayName</code></li><li>解决方式：为高阶组件设置 <code>displayName</code>，便于调试时区分不同的组件</li><li><code>displayName的作用：用于设置调试信息(React Developer Tools信息)</code></li><li>设置方式：</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-displayName.png" class="lozad post-image"src="images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-displayName.png"></p><h2 id="传递props"><a href="#传递props" class="headerlink" title="传递props"></a>传递props</h2><ul><li>问题：如果没有传递props，会导致props丢失问题</li><li>解决方式： 渲染 <code>WrappedComponent</code>时，将state和props一起传递给组件</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E4%BC%A0%E9%80%92props.png" class="lozad post-image"src="images/%E4%BC%A0%E9%80%92props.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>组件通讯是构建React应用必不可少的一环</li><li>props的灵活性让组件更加强大</li><li>状态提升是React组件的常用模式</li><li>组件生命周期有助于理解组件的运行过程</li><li>钩子函数让开发者可以在特定的时机执行某些功能</li><li><code>render props</code> 模式和高阶组件都可以实现组件状态逻辑的复用</li><li>组件极简模型： <code>(state,props) =&gt; UI</code></li></ul><h1 id="React原理"><a href="#React原理" class="headerlink" title="React原理"></a>React原理</h1><h2 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h2><ul><li>能够知道 <code>setState()</code>更新数据是异步的</li><li>能够知道JSX语法的转化过程</li></ul><h2 id="setState-说明-（★★★）"><a href="#setState-说明-（★★★）" class="headerlink" title="setState()说明 （★★★）"></a><code>setState()</code>说明 （★★★）</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><ul><li><code>setState()</code>更新数据是异步的</li><li>注意：使用该语法，后面的 <code>setState</code>不要依赖前面 <code>setState</code>的值</li><li>多次调用 <code>setState</code>，只会触发一次render</li></ul><h3 id="推荐语法"><a href="#推荐语法" class="headerlink" title="推荐语法"></a>推荐语法</h3><ul><li>推荐：使用 <code>setState((state,props) =&gt; &#123;&#125;)</code> 语法</li><li>参数state： 表示最新的state</li><li>参数props： 表示最新的props</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E6%8E%A8%E8%8D%90%E8%AF%AD%E6%B3%95.png" class="lozad post-image"src="images/%E6%8E%A8%E8%8D%90%E8%AF%AD%E6%B3%95.png"></p><h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><ul><li>场景：在状态更新(页面完成重新渲染)后立即执行某个操作</li><li>语法：<code>setState(update[,callback])</code></li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0.png" class="lozad post-image"src="images/%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0.png"></p><h2 id="JSX语法的转化过程-（★★★）"><a href="#JSX语法的转化过程-（★★★）" class="headerlink" title="JSX语法的转化过程 （★★★）"></a>JSX语法的转化过程 （★★★）</h2><ul><li>JSX仅仅是 <code>createElement()</code> 方法的语法糖(简化语法)</li><li>JSX语法被 @babel/preset-react 插件编译为 <code>createElement()</code> 方法</li><li>React 元素： 是一个对象，用来描述你希望在屏幕上看到的内容</li></ul><p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="images/%E8%AF%AD%E6%B3%95%E7%B3%96.png" class="lozad post-image"src="images/%E8%AF%AD%E6%B3%95%E7%B3%96.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组件生命周期（★★★）&quot;&gt;&lt;a href=&quot;#组件生命周期（★★★）&quot; class=&quot;headerlink&quot; title=&quot;组件生命周期（★★★）&quot;&gt;&lt;/a&gt;组件生命周期（★★★）&lt;/h1&gt;&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/04/24/hello-world/"/>
    <id>http://example.com/2023/04/24/hello-world/</id>
    <published>2023-04-24T07:25:18.631Z</published>
    <updated>2023-04-24T07:08:58.726Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="highlight"><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="highlight"><span class="line">$ hexo server</span><br></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="highlight"><span class="line">$ hexo generate</span><br></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="highlight"><span class="line">$ hexo deploy</span><br></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
